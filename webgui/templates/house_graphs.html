{% extends "base.html" %}
{% block title %}Graphs - {{ friendly_name }}{% endblock %}

{% block content %}
<div class="house-detail">
    <div class="page-header">
        <a href="{{ url_for('house_detail', house_id=house_id) }}" class="back-link">&larr; Back to {{ friendly_name }}</a>
        <h1 class="friendly-name">Data Overview</h1>
        <p class="subtitle">{{ friendly_name }}</p>
    </div>

    <!-- Data Availability Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Data Availability</h2>
            <div class="chart-controls">
                <select id="days-select" class="role-select" onchange="updateChart()">
                    <option value="7">Last 7 days</option>
                    <option value="30" selected>Last 30 days</option>
                    <option value="90">Last 90 days</option>
                    <option value="365">Last year</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Shows data coverage per category. Darker blue = more data points.
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color predicted"></span> * = Predicted data</span>
            </span>
        </p>

        {% if availability.categories %}
        <div id="availability-chart" class="chart-container"></div>
        {% else %}
        <p class="muted">No data available for this house yet.</p>
        {% endif %}
    </div>

    <!-- Effective Temperature Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Effective Outdoor Temperature</h2>
            <div class="chart-controls">
                <select id="eff-temp-days-select" class="role-select" onchange="updateEffectiveTempChart()">
                    <option value="24">Last 24 hours</option>
                    <option value="72">Last 3 days</option>
                    <option value="168" selected>Last 7 days</option>
                    <option value="336">Last 14 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Compares actual outdoor temperature with "effective" temperature
            that accounts for wind chill, humidity, and solar effects.
            <strong>Dotted</strong> = effective temp. <strong>Dashed</strong> = 12h forecast.
        </p>
        <div id="effective-temp-chart" class="chart-container"></div>
    </div>

    <!-- Effect Breakdown Chart -->
    <div class="card">
        <h2>Weather Effect Breakdown</h2>
        <p class="card-description">
            Shows how wind, humidity, and solar radiation affect the effective temperature.
            Negative values = colder, Positive = warmer.
        </p>
        <div id="effect-breakdown-chart" class="chart-container"></div>
    </div>

    <!-- Primary vs Secondary Temperature Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Primary vs Secondary Temperatures</h2>
            <div class="chart-controls">
                <select id="temp-history-days-select" class="role-select" onchange="updateTemperatureHistoryChart()">
                    <option value="24">Last 24 hours</option>
                    <option value="72">Last 3 days</option>
                    <option value="168" selected>Last 7 days</option>
                    <option value="336">Last 14 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Compares <strong>District Heating</strong> (primary side from utility) with
            <strong>House Heating</strong> (secondary side to radiators).
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color dh-supply"></span> DH Supply</span>
                <span class="legend-item"><span class="legend-color dh-return"></span> DH Return</span>
                <span class="legend-item"><span class="legend-color house-supply"></span> House Supply</span>
                <span class="legend-item"><span class="legend-color house-return"></span> House Return</span>
                <span class="legend-item"><span class="legend-color" style="background: #9b59b6;"></span> Predicted Supply</span>
            </span>
        </p>
        <div id="temp-history-chart" class="chart-container"></div>
    </div>

    <!-- Efficiency Metrics Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Efficiency Metrics (Delta T)</h2>
            <div class="chart-controls">
                <select id="efficiency-days-select" class="role-select" onchange="updateEfficiencyChart()">
                    <option value="24">Last 24 hours</option>
                    <option value="72">Last 3 days</option>
                    <option value="168" selected>Last 7 days</option>
                    <option value="336">Last 14 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            <strong>Delta T</strong> shows temperature difference between supply and return.
            Higher DH delta T = more heat extracted from district heating.
            Good values: DH 25-40°C, House 5-15°C.
        </p>
        <div id="efficiency-chart" class="chart-container"></div>
        <div id="efficiency-summary" class="metric-summary"></div>
    </div>

    <!-- Energy Separation Chart (Heating vs DHW) -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Energy Breakdown (Heating vs Hot Water)</h2>
            <div class="chart-controls">
                <select id="separation-days-select" class="role-select" onchange="updateEnergySeparationChart()">
                    <option value="7">Last 7 days</option>
                    <option value="30" selected>Last 30 days</option>
                    <option value="90">Last 90 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Separates total energy into <strong>space heating</strong> and <strong>domestic hot water (DHW)</strong>
            using calibrated building heat loss model.
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color heating-energy"></span> Heating</span>
                <span class="legend-item"><span class="legend-color dhw-energy"></span> Hot Water</span>
            </span>
        </p>
        <div id="separation-chart" class="chart-container"></div>
        <div id="separation-summary" class="metric-summary"></div>
    </div>

    <!-- K-Value History Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Heat Loss Coefficient (k) History</h2>
            <div class="chart-controls">
                <select id="k-history-days-select" class="role-select" onchange="updateKValueChart()">
                    <option value="7">Last 7 days</option>
                    <option value="30" selected>Last 30 days</option>
                    <option value="90">Last 90 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Shows how the building's heat loss coefficient (k) converges over time.
            When the line flattens, the calibration has stabilized.
            <strong>k = kW per °C difference</strong> between indoor and outdoor temperature.
        </p>
        <div id="k-value-chart" class="chart-container"></div>
        <div id="k-value-summary" class="metric-summary"></div>
    </div>

    <!-- Cost Estimate Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Cost Estimate<span id="cost-data-source" class="data-source-badge" style="display:none;"></span></h2>
            <div class="chart-controls">
                <label class="price-label">
                    Price (SEK/kWh):
                    <input type="number" id="price-input" class="price-input" value="1.20" step="0.01" min="0" onchange="updateCostChart()">
                </label>
                <select id="cost-days-select" class="role-select" onchange="updateCostChart()">
                    <option value="7">Last 7 days</option>
                    <option value="30" selected>Last 30 days</option>
                    <option value="90">Last 90 days</option>
                    <option value="365">Last year</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Estimated heating costs based on energy consumption and price per kWh.
            Default price is typical Swedish district heating rate.
        </p>
        <div id="cost-chart" class="chart-container"></div>
        <div id="cost-summary" class="cost-summary-box"></div>
    </div>
</div>

<style>
.card-header-flex {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}
.card-header-flex h2 {
    margin: 0;
}
.chart-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}
.chart-container {
    width: 100%;
    min-height: 300px;
}
.legend-inline {
    display: inline-flex;
    gap: 15px;
    margin-left: 10px;
}
.legend-item {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    font-size: 0.85em;
    color: var(--muted);
}
.legend-color {
    width: 12px;
    height: 12px;
    border-radius: 2px;
}
.legend-color.measured {
    background: #3498db;
}
.legend-color.predicted {
    background: #9b59b6;
}
.feature-list {
    margin: 15px 0;
    padding-left: 20px;
}
.feature-list li {
    margin: 8px 0;
    color: var(--muted);
}
.loading-spinner {
    padding: 40px;
    text-align: center;
    color: var(--muted);
    font-style: italic;
}
/* Data source badges */
.data-source-badge {
    display: inline-block;
    font-size: 0.7rem;
    font-weight: 600;
    padding: 3px 8px;
    border-radius: 4px;
    margin-left: 10px;
    vertical-align: middle;
    text-transform: uppercase;
}
.data-source-badge.live {
    background: #27ae60;
    color: white;
}
.data-source-badge.imported {
    background: #3498db;
    color: white;
}
/* Temperature legend colors */
.legend-color.dh-supply {
    background: #e74c3c;
}
.legend-color.dh-return {
    background: #c0392b;
}
.legend-color.house-supply {
    background: #3498db;
}
.legend-color.house-return {
    background: #2980b9;
}
.legend-color.heating-energy {
    background: #3498db;
}
.legend-color.dhw-energy {
    background: #e67e22;
}
/* Metric summary boxes */
.metric-summary {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    margin-top: 15px;
    padding: 15px;
    background: var(--card-bg, #f8f9fa);
    border-radius: 8px;
}
.metric-item {
    text-align: center;
    min-width: 100px;
}
.metric-value {
    font-size: 1.5em;
    font-weight: 600;
    color: var(--primary, #3498db);
}
.metric-label {
    font-size: 0.85em;
    color: var(--muted);
    margin-top: 4px;
}
/* Cost summary box */
.cost-summary-box {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
    margin-top: 15px;
    padding: 20px;
    background: linear-gradient(135deg, #e8f4fd 0%, #d4edda 100%);
    border-radius: 8px;
}
.cost-item {
    text-align: center;
}
.cost-item.highlight {
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.cost-value {
    font-size: 1.8em;
    font-weight: 700;
    color: #27ae60;
}
.cost-value.projection {
    color: #2980b9;
}
.cost-label {
    font-size: 0.85em;
    color: var(--muted);
    margin-top: 4px;
}
/* Price input styling */
.price-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9em;
    color: var(--muted);
}
.price-input {
    width: 70px;
    padding: 4px 8px;
    border: 1px solid var(--border, #ddd);
    border-radius: 4px;
    font-size: 0.9em;
}
/* No data message */
.no-data-message {
    padding: 40px;
    text-align: center;
    color: var(--muted);
    font-style: italic;
    background: var(--card-bg, #f8f9fa);
    border-radius: 8px;
}
</style>

<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script>
    const houseId = "{{ house_id }}";
    let currentChart = null;

    // Initial chart data from server
    const initialData = {{ graph_json | safe }};
    const chartConfig = {{ config_json | safe }};

    function renderChart(data) {
        Plotly.newPlot('availability-chart', data.data, data.layout, chartConfig);
    }

    // Helper function to update data source badge
    function updateDataSourceBadge(elementId, dataSource) {
        const badge = document.getElementById(elementId);
        if (!badge) return;

        if (dataSource === 'live') {
            badge.textContent = 'Live Data';
            badge.className = 'data-source-badge live';
            badge.style.display = 'inline-block';
        } else if (dataSource === 'imported') {
            badge.textContent = 'Imported Data';
            badge.className = 'data-source-badge imported';
            badge.style.display = 'inline-block';
        } else {
            badge.style.display = 'none';
        }
    }

    function updateChart() {
        const days = document.getElementById('days-select').value;
        const chartDiv = document.getElementById('availability-chart');

        // Show loading state
        chartDiv.style.opacity = '0.5';

        fetch(`/api/house/${houseId}/data-availability?days=${days}`)
            .then(response => response.json())
            .then(availability => {
                if (!availability.categories || availability.categories.length === 0) {
                    chartDiv.innerHTML = '<p class="muted">No data available.</p>';
                    chartDiv.style.opacity = '1';
                    return;
                }

                // Collect all unique dates
                const allDatesSet = new Set();
                availability.categories.forEach(cat => {
                    cat.data.forEach(d => allDatesSet.add(d.date));
                });
                const allDates = Array.from(allDatesSet).sort();

                // Build heatmap data
                const categoryNames = availability.categories.map(c => c.name);
                const zValues = availability.categories.map(cat => {
                    const dateToCount = {};
                    cat.data.forEach(d => { dateToCount[d.date] = d.count; });
                    return allDates.map(date => dateToCount[date] || 0);
                });

                const traces = [{
                    z: zValues,
                    x: allDates,
                    y: categoryNames,
                    type: 'heatmap',
                    colorscale: [
                        [0, '#f8f9fa'],
                        [0.01, '#e3f2fd'],
                        [0.25, '#90caf9'],
                        [0.5, '#42a5f5'],
                        [1, '#1565c0']
                    ],
                    showscale: true,
                    colorbar: {
                        title: { text: 'Data points', side: 'right' }
                    },
                    hovertemplate: '%{x}<br>%{y}: %{z} points<extra></extra>'
                }];

                const layout = {
                    xaxis: {
                        title: 'Date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        tickangle: -45
                    },
                    yaxis: {
                        title: null,
                        autorange: 'reversed'
                    },
                    height: Math.max(300, availability.categories.length * 40 + 150),
                    margin: { l: 130, r: 80, t: 20, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    dragmode: 'pan'
                };

                Plotly.react('availability-chart', traces, layout, chartConfig);
                chartDiv.style.opacity = '1';
            })
            .catch(error => {
                console.error('Failed to update chart:', error);
                chartDiv.style.opacity = '1';
            });
    }

    // Effective Temperature Chart (with forecast)
    function updateEffectiveTempChart() {
        const hours = document.getElementById('eff-temp-days-select').value;
        const chartDiv = document.getElementById('effective-temp-chart');
        const breakdownDiv = document.getElementById('effect-breakdown-chart');

        console.log(`Fetching effective temp for house=${houseId}, hours=${hours}`);

        const historyUrl = `/api/house/${houseId}/effective-temperature?hours=${hours}`;
        const forecastUrl = `/api/house/${houseId}/forecast-effective-temperature?hours=12`;

        // Fetch both historical and forecast data in parallel
        Promise.all([
            fetch(historyUrl).then(r => r.ok ? r.json() : { data: [] }),
            fetch(forecastUrl).then(r => r.ok ? r.json() : { data: [] })
        ])
        .then(([historyResult, forecastResult]) => {
            console.log('History data:', historyResult.data?.length || 0, 'points');
            console.log('Forecast data:', forecastResult.data?.length || 0, 'points');

            const histData = historyResult.data || [];
            const forecastData = forecastResult.data || [];

            if (histData.length === 0 && forecastData.length === 0) {
                chartDiv.innerHTML = '<p class="muted">No weather data available.</p>';
                breakdownDiv.innerHTML = '';
                return;
            }

            // Historical data timestamps
            const histTimestamps = histData.map(d => d.timestamp_display || d.timestamp);
            // Forecast data timestamps
            const forecastTimestamps = forecastData.map(d => d.timestamp_display || d.timestamp);

            // Get current time for "now" line (use last historical point or current time)
            const nowTime = histTimestamps.length > 0 ? histTimestamps[histTimestamps.length - 1] : null;

            // Main temperature comparison chart with forecast
            const tempTraces = [
                // Historical actual outdoor
                {
                    x: histTimestamps,
                    y: histData.map(d => d.actual_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Actual Outdoor',
                    line: { color: '#3498db', width: 2 },
                    hovertemplate: '%{x}<br>Actual: %{y}°C<extra></extra>'
                },
                // Historical effective temp
                {
                    x: histTimestamps,
                    y: histData.map(d => d.effective_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Effective Temp',
                    line: { color: '#e74c3c', width: 2, dash: 'dot' },
                    hovertemplate: '%{x}<br>Effective: %{y}°C<extra></extra>'
                }
            ];

            // Add forecast traces if we have forecast data
            if (forecastData.length > 0) {
                // Forecast outdoor temp (dashed)
                tempTraces.push({
                    x: forecastTimestamps,
                    y: forecastData.map(d => d.forecast_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Forecast Outdoor',
                    line: { color: '#3498db', width: 2, dash: 'dash' },
                    hovertemplate: '%{x}<br>Forecast: %{y}°C<extra></extra>'
                });
                // Forecast effective temp (dashed + dotted)
                tempTraces.push({
                    x: forecastTimestamps,
                    y: forecastData.map(d => d.effective_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Forecast Effective',
                    line: { color: '#e74c3c', width: 2, dash: 'dashdot' },
                    hovertemplate: '%{x}<br>Forecast Eff: %{y}°C<extra></extra>'
                });
            }

            const tempLayout = {
                xaxis: {
                    title: 'Time',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)'
                },
                yaxis: {
                    title: 'Temperature (°C)',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)'
                },
                height: 350,
                margin: { l: 60, r: 30, t: 30, b: 60 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#ffffff',
                font: { family: 'system-ui, -apple-system, sans-serif' },
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: 1.02,
                    xanchor: 'right',
                    x: 1
                },
                dragmode: 'pan',
                hovermode: 'x unified',
                // Add vertical "now" line
                shapes: nowTime ? [{
                    type: 'line',
                    x0: nowTime,
                    x1: nowTime,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: { color: 'rgba(0,0,0,0.3)', width: 2, dash: 'dot' }
                }] : [],
                annotations: nowTime ? [{
                    x: nowTime,
                    y: 1,
                    yref: 'paper',
                    text: 'Now',
                    showarrow: false,
                    font: { size: 10, color: 'rgba(0,0,0,0.5)' },
                    yanchor: 'bottom'
                }] : []
            };

            Plotly.newPlot('effective-temp-chart', tempTraces, tempLayout, chartConfig);

            // Effect breakdown chart (historical + forecast)
            const breakdownTraces = [
                // Historical wind effect
                {
                    x: histTimestamps,
                    y: histData.map(d => d.wind_effect),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Wind Effect',
                    fill: 'tozeroy',
                    line: { color: '#9b59b6', width: 1 },
                    fillcolor: 'rgba(155, 89, 182, 0.3)',
                    hovertemplate: '%{x}<br>Wind: %{y}°C<extra></extra>'
                },
                // Historical humidity effect
                {
                    x: histTimestamps,
                    y: histData.map(d => d.humidity_effect),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Humidity Effect',
                    fill: 'tozeroy',
                    line: { color: '#3498db', width: 1 },
                    fillcolor: 'rgba(52, 152, 219, 0.3)',
                    hovertemplate: '%{x}<br>Humidity: %{y}°C<extra></extra>'
                },
                // Historical solar effect
                {
                    x: histTimestamps,
                    y: histData.map(d => d.solar_effect),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Solar Effect',
                    fill: 'tozeroy',
                    line: { color: '#f39c12', width: 1 },
                    fillcolor: 'rgba(243, 156, 18, 0.3)',
                    hovertemplate: '%{x}<br>Solar: %{y}°C<extra></extra>'
                }
            ];

            // Add forecast effect traces
            if (forecastData.length > 0) {
                breakdownTraces.push(
                    {
                        x: forecastTimestamps,
                        y: forecastData.map(d => d.wind_effect),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Wind (forecast)',
                        line: { color: '#9b59b6', width: 2, dash: 'dash' },
                        hovertemplate: '%{x}<br>Wind (fcst): %{y}°C<extra></extra>'
                    },
                    {
                        x: forecastTimestamps,
                        y: forecastData.map(d => d.humidity_effect),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Humidity (forecast)',
                        line: { color: '#3498db', width: 2, dash: 'dash' },
                        hovertemplate: '%{x}<br>Humidity (fcst): %{y}°C<extra></extra>'
                    },
                    {
                        x: forecastTimestamps,
                        y: forecastData.map(d => d.solar_effect),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Solar (forecast)',
                        line: { color: '#f39c12', width: 2, dash: 'dash' },
                        hovertemplate: '%{x}<br>Solar (fcst): %{y}°C<extra></extra>'
                    }
                );
            }

            const breakdownLayout = {
                xaxis: {
                    title: 'Time',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)'
                },
                yaxis: {
                    title: 'Effect (°C)',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)',
                    zeroline: true,
                    zerolinecolor: 'rgba(0,0,0,0.3)',
                    zerolinewidth: 1
                },
                height: 280,
                margin: { l: 60, r: 30, t: 30, b: 60 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#ffffff',
                font: { family: 'system-ui, -apple-system, sans-serif' },
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: 1.02,
                    xanchor: 'right',
                    x: 1
                },
                dragmode: 'pan',
                hovermode: 'x unified',
                // Add vertical "now" line
                shapes: nowTime ? [{
                    type: 'line',
                    x0: nowTime,
                    x1: nowTime,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: { color: 'rgba(0,0,0,0.3)', width: 2, dash: 'dot' }
                }] : []
            };

            Plotly.newPlot('effect-breakdown-chart', breakdownTraces, breakdownLayout, chartConfig);
        })
        .catch(error => {
            console.error('Failed to load effective temperature data:', error);
            chartDiv.innerHTML = '<p class="muted">Failed to load weather data.</p>';
            breakdownDiv.innerHTML = '';
        });
    }

    // Primary vs Secondary Temperature Chart with dynamic pan loading
    // Track chart state for dynamic loading
    const tempHistoryState = {
        loadedHours: 0,
        isLoading: false,
        data: [],
        minLoadedTime: null,
        maxLoadedTime: null
    };

    function buildTempHistoryTraces(data) {
        const timestamps = data.map(d => d.timestamp_display);
        return [
            // DH Primary Side
            {
                x: timestamps,
                y: data.map(d => d.dh_supply_temp),
                type: 'scatter',
                mode: 'lines',
                name: 'DH Supply',
                line: { color: '#e74c3c', width: 2 },
                hovertemplate: '%{x}<br>DH Supply: %{y}°C<extra></extra>'
            },
            {
                x: timestamps,
                y: data.map(d => d.dh_return_temp),
                type: 'scatter',
                mode: 'lines',
                name: 'DH Return',
                line: { color: '#c0392b', width: 2, dash: 'dot' },
                hovertemplate: '%{x}<br>DH Return: %{y}°C<extra></extra>'
            },
            // House Secondary Side
            {
                x: timestamps,
                y: data.map(d => d.supply_temp),
                type: 'scatter',
                mode: 'lines',
                name: 'House Supply',
                line: { color: '#3498db', width: 2 },
                hovertemplate: '%{x}<br>House Supply: %{y}°C<extra></extra>'
            },
            {
                x: timestamps,
                y: data.map(d => d.return_temp),
                type: 'scatter',
                mode: 'lines',
                name: 'House Return',
                line: { color: '#2980b9', width: 2, dash: 'dot' },
                hovertemplate: '%{x}<br>House Return: %{y}°C<extra></extra>'
            },
            // Outdoor reference
            {
                x: timestamps,
                y: data.map(d => d.outdoor_temperature),
                type: 'scatter',
                mode: 'lines',
                name: 'Outdoor',
                line: { color: '#95a5a6', width: 1, dash: 'dash' },
                hovertemplate: '%{x}<br>Outdoor: %{y}°C<extra></extra>'
            },
            // Predicted supply temp (using effective temperature)
            {
                x: timestamps,
                y: data.map(d => d.supply_temp_heat_curve_ml),
                type: 'scatter',
                mode: 'lines',
                name: 'Predicted Supply',
                line: { color: '#9b59b6', width: 2, dash: 'dashdot' },
                hovertemplate: '%{x}<br>Predicted Supply: %{y}°C<extra></extra>'
            }
        ];
    }

    function updateTemperatureHistoryChart(extendHours = null) {
        const selectEl = document.getElementById('temp-history-days-select');
        const hours = extendHours || parseInt(selectEl.value);
        const chartDiv = document.getElementById('temp-history-chart');

        // If extending, don't show full loading spinner - just indicate loading
        if (!extendHours) {
            chartDiv.innerHTML = '<div class="loading-spinner">Loading temperature data...</div>';
            tempHistoryState.data = [];
        }
        tempHistoryState.isLoading = true;

        fetch(`/api/house/${houseId}/temperature-history?hours=${hours}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                tempHistoryState.isLoading = false;
                const data = result.data || [];

                if (data.length === 0 && !extendHours) {
                    chartDiv.innerHTML = '<div class="no-data-message">No temperature data available. DH variables may not be configured.</div>';
                    return;
                }

                // Update state
                tempHistoryState.loadedHours = hours;
                tempHistoryState.data = data;
                if (data.length > 0) {
                    tempHistoryState.minLoadedTime = new Date(data[0].timestamp);
                    tempHistoryState.maxLoadedTime = new Date(data[data.length - 1].timestamp);
                }

                const traces = buildTempHistoryTraces(data);

                const layout = {
                    xaxis: { title: 'Time', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    yaxis: { title: 'Temperature (°C)', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    height: 400,
                    margin: { l: 60, r: 30, t: 30, b: 60 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: { orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1 },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                if (!extendHours) {
                    chartDiv.innerHTML = '';  // Clear loading message
                }

                // Use react for updates, newPlot for initial
                const plotFn = extendHours ? Plotly.react : Plotly.newPlot;
                plotFn('temp-history-chart', traces, layout, chartConfig)
                    .then(() => {
                        // Add pan handler for dynamic loading (only on initial plot)
                        if (!extendHours) {
                            document.getElementById('temp-history-chart').on('plotly_relayout', (e) => handleChartPan(e, tempHistoryState, 'temp-history-days-select', updateTemperatureHistoryChart));
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        if (!extendHours) {
                            chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                        }
                    });
            })
            .catch(error => {
                tempHistoryState.isLoading = false;
                console.error('Failed to load temperature history:', error);
                if (!extendHours) {
                    chartDiv.innerHTML = '<div class="no-data-message">Failed to load temperature data.</div>';
                }
            });
    }

    // Parse Plotly's display time format "YYYY-MM-DD HH:MM" to Date
    function parseDisplayTime(timeStr) {
        if (!timeStr) return null;
        try {
            // Handle both ISO format and display format
            if (timeStr.includes('T')) {
                return new Date(timeStr);
            }
            // Display format: "2026-01-15 14:30"
            const [datePart, timePart] = timeStr.split(' ');
            if (!datePart) return null;
            const [year, month, day] = datePart.split('-').map(Number);
            const [hour, minute] = (timePart || '00:00').split(':').map(Number);
            return new Date(year, month - 1, day, hour, minute);
        } catch (e) {
            console.warn('Failed to parse time:', timeStr, e);
            return null;
        }
    }

    // Generic pan handler for all charts with hours-based data
    function handleChartPan(eventData, state, selectId, updateFn, maxHours = 720) {
        if (state.isLoading || !eventData['xaxis.range[0]']) return;

        const visibleStart = parseDisplayTime(eventData['xaxis.range[0]']);
        const visibleEnd = parseDisplayTime(eventData['xaxis.range[1]']);

        if (!visibleStart || !visibleEnd || !state.minLoadedTime) return;

        const loadedRange = state.maxLoadedTime - state.minLoadedTime;
        const buffer = loadedRange * 0.1;

        const needsMore = visibleStart < new Date(state.minLoadedTime.getTime() + buffer) ||
                          visibleEnd > new Date(state.maxLoadedTime.getTime() - buffer);

        if (needsMore) {
            const newHours = Math.min(state.loadedHours * 2, maxHours);
            if (newHours > state.loadedHours) {
                console.log(`Extending ${selectId} data from ${state.loadedHours}h to ${newHours}h`);
                updateFn(newHours);

                const selectEl = document.getElementById(selectId);
                if (selectEl) {
                    const options = Array.from(selectEl.options).map(o => parseInt(o.value));
                    const closest = options.reduce((p, c) => Math.abs(c - newHours) < Math.abs(p - newHours) ? c : p);
                    selectEl.value = closest.toString();
                }
            }
        }
    }

    // Generic pan handler for charts with days-based data
    function handleChartPanDays(eventData, state, selectId, updateFn, maxDays = 365) {
        if (state.isLoading || !eventData['xaxis.range[0]']) return;

        const visibleStart = parseDisplayTime(eventData['xaxis.range[0]']);
        const visibleEnd = parseDisplayTime(eventData['xaxis.range[1]']);

        if (!visibleStart || !visibleEnd || !state.minLoadedTime) return;

        const loadedRange = state.maxLoadedTime - state.minLoadedTime;
        const buffer = loadedRange * 0.1;

        const needsMore = visibleStart < new Date(state.minLoadedTime.getTime() + buffer) ||
                          visibleEnd > new Date(state.maxLoadedTime.getTime() - buffer);

        if (needsMore) {
            const newDays = Math.min(state.loadedDays * 2, maxDays);
            if (newDays > state.loadedDays) {
                console.log(`Extending ${selectId} data from ${state.loadedDays}d to ${newDays}d`);
                updateFn(newDays);

                const selectEl = document.getElementById(selectId);
                if (selectEl) {
                    const options = Array.from(selectEl.options).map(o => parseInt(o.value));
                    const closest = options.reduce((p, c) => Math.abs(c - newDays) < Math.abs(p - newDays) ? c : p);
                    selectEl.value = closest.toString();
                }
            }
        }
    }

    // Efficiency Metrics Chart (Delta T) with dynamic pan loading
    const efficiencyState = {
        loadedHours: 0,
        isLoading: false,
        minLoadedTime: null,
        maxLoadedTime: null
    };

    function buildEfficiencyTraces(data) {
        const timestamps = data.map(d => d.timestamp_display);
        return [
            {
                x: timestamps,
                y: data.map(d => d.dh_delta_t),
                type: 'scatter',
                mode: 'lines',
                name: 'DH Delta T',
                fill: 'tozeroy',
                line: { color: '#e74c3c', width: 2 },
                fillcolor: 'rgba(231, 76, 60, 0.2)',
                hovertemplate: '%{x}<br>DH ΔT: %{y}°C<extra></extra>'
            },
            {
                x: timestamps,
                y: data.map(d => d.house_delta_t),
                type: 'scatter',
                mode: 'lines',
                name: 'House Delta T',
                fill: 'tozeroy',
                line: { color: '#3498db', width: 2 },
                fillcolor: 'rgba(52, 152, 219, 0.2)',
                hovertemplate: '%{x}<br>House ΔT: %{y}°C<extra></extra>'
            }
        ];
    }

    function updateEfficiencyChart(extendHours = null) {
        const selectEl = document.getElementById('efficiency-days-select');
        const hours = extendHours || parseInt(selectEl.value);
        const chartDiv = document.getElementById('efficiency-chart');
        const summaryDiv = document.getElementById('efficiency-summary');

        if (!extendHours) {
            chartDiv.innerHTML = '<div class="loading-spinner">Loading efficiency data...</div>';
            summaryDiv.innerHTML = '';
        }
        efficiencyState.isLoading = true;

        fetch(`/api/house/${houseId}/efficiency-metrics?hours=${hours}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                efficiencyState.isLoading = false;
                const data = result.data || [];
                const summary = result.summary || {};

                if (data.length === 0 && !extendHours) {
                    chartDiv.innerHTML = '<div class="no-data-message">No efficiency data available.</div>';
                    return;
                }

                // Update state
                efficiencyState.loadedHours = hours;
                if (data.length > 0) {
                    efficiencyState.minLoadedTime = new Date(data[0].timestamp);
                    efficiencyState.maxLoadedTime = new Date(data[data.length - 1].timestamp);
                }

                const traces = buildEfficiencyTraces(data);

                const layout = {
                    xaxis: { title: 'Time', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    yaxis: { title: 'Delta T (°C)', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    height: 350,
                    margin: { l: 60, r: 30, t: 30, b: 60 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: { orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1 },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                if (!extendHours) {
                    chartDiv.innerHTML = '';
                }

                const plotFn = extendHours ? Plotly.react : Plotly.newPlot;
                plotFn('efficiency-chart', traces, layout, chartConfig)
                    .then(() => {
                        if (!extendHours) {
                            document.getElementById('efficiency-chart').on('plotly_relayout', (e) => handleChartPan(e, efficiencyState, 'efficiency-days-select', updateEfficiencyChart));
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        if (!extendHours) chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });

                // Update summary
                if (!extendHours) {
                    summaryDiv.innerHTML = `
                        <div class="metric-item">
                            <div class="metric-value">${summary.avg_dh_delta_t || '-'}°C</div>
                            <div class="metric-label">Avg DH Delta T</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${summary.avg_house_delta_t || '-'}°C</div>
                            <div class="metric-label">Avg House Delta T</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${summary.avg_power || '-'} kW</div>
                            <div class="metric-label">Avg Power</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${summary.max_power || '-'} kW</div>
                            <div class="metric-label">Peak Power</div>
                        </div>
                    `;
                }
            })
            .catch(error => {
                efficiencyState.isLoading = false;
                console.error('Failed to load efficiency data:', error);
                if (!extendHours) chartDiv.innerHTML = '<div class="no-data-message">Failed to load efficiency data.</div>';
            });
    }

    // Cost Estimate Chart with dynamic pan loading
    const costState = {
        loadedDays: 0,
        isLoading: false,
        minLoadedTime: null,
        maxLoadedTime: null
    };

    function updateCostChart(extendDays = null) {
        const selectEl = document.getElementById('cost-days-select');
        const days = extendDays || parseInt(selectEl.value);
        const price = document.getElementById('price-input').value || 1.20;
        const chartDiv = document.getElementById('cost-chart');
        const summaryDiv = document.getElementById('cost-summary');

        if (!extendDays) {
            chartDiv.innerHTML = '<div class="loading-spinner">Loading cost data...</div>';
            summaryDiv.innerHTML = '';
        }
        costState.isLoading = true;

        fetch(`/api/house/${houseId}/cost-estimate?days=${days}&price=${price}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                costState.isLoading = false;
                const data = result.data || [];
                const summary = result.summary || {};

                // Update data source badge
                if (!extendDays) {
                    updateDataSourceBadge('cost-data-source', result.data_source);
                }

                if (data.length === 0 && !extendDays) {
                    chartDiv.innerHTML = '<div class="no-data-message">No cost data available. Import energy data first.</div>';
                    return;
                }

                // Update state
                costState.loadedDays = days;
                if (data.length > 0) {
                    costState.minLoadedTime = new Date(data[0].timestamp);
                    costState.maxLoadedTime = new Date(data[data.length - 1].timestamp);
                }

                // Group by date for daily costs
                const dailyCosts = {};
                data.forEach(d => {
                    const date = d.timestamp_display.split(' ')[0];
                    if (!dailyCosts[date]) dailyCosts[date] = 0;
                    dailyCosts[date] += d.cost;
                });

                const dates = Object.keys(dailyCosts).sort();
                const costs = dates.map(d => Math.round(dailyCosts[d] * 100) / 100);

                const traces = [{
                    x: dates,
                    y: costs,
                    type: 'bar',
                    name: 'Daily Cost',
                    marker: {
                        color: costs.map(c => c > summary.daily_avg_cost * 1.5 ? '#e74c3c' : '#27ae60')
                    },
                    hovertemplate: '%{x}<br>%{y} SEK<extra></extra>'
                }];

                // Add average line
                if (summary.daily_avg_cost) {
                    traces.push({
                        x: [dates[0], dates[dates.length - 1]],
                        y: [summary.daily_avg_cost, summary.daily_avg_cost],
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Daily Avg',
                        line: { color: '#f39c12', width: 2, dash: 'dash' },
                        hovertemplate: 'Average: %{y} SEK<extra></extra>'
                    });
                }

                const layout = {
                    xaxis: { title: 'Date', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    yaxis: { title: 'Cost (SEK)', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)', rangemode: 'tozero' },
                    height: 350,
                    margin: { l: 60, r: 30, t: 30, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: { orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1 },
                    dragmode: 'pan'
                };

                if (!extendDays) {
                    chartDiv.innerHTML = '';
                }

                const plotFn = extendDays ? Plotly.react : Plotly.newPlot;
                plotFn('cost-chart', traces, layout, chartConfig)
                    .then(() => {
                        if (!extendDays) {
                            document.getElementById('cost-chart').on('plotly_relayout', (e) => handleChartPanDays(e, costState, 'cost-days-select', updateCostChart));
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        if (!extendDays) chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });

                // Update summary
                if (!extendDays) {
                    summaryDiv.innerHTML = `
                        <div class="cost-item">
                            <div class="cost-value">${summary.total_kwh || 0} kWh</div>
                            <div class="cost-label">Total Energy</div>
                        </div>
                        <div class="cost-item highlight">
                            <div class="cost-value">${summary.total_cost || 0} SEK</div>
                            <div class="cost-label">Total Cost (${days} days)</div>
                        </div>
                        <div class="cost-item">
                            <div class="cost-value">${summary.daily_avg_kwh || 0} kWh</div>
                            <div class="cost-label">Daily Avg Energy</div>
                        </div>
                        <div class="cost-item">
                            <div class="cost-value">${summary.daily_avg_cost || 0} SEK</div>
                            <div class="cost-label">Daily Avg Cost</div>
                        </div>
                        <div class="cost-item highlight">
                            <div class="cost-value projection">${summary.monthly_projection || 0} SEK</div>
                            <div class="cost-label">Monthly Projection</div>
                        </div>
                    `;
                }
            })
            .catch(error => {
                costState.isLoading = false;
                console.error('Failed to load cost data:', error);
                if (!extendDays) chartDiv.innerHTML = '<div class="no-data-message">Failed to load cost data.</div>';
            });
    }

    // Energy Separation Chart (Heating vs DHW) with dynamic pan loading
    const separationState = {
        loadedDays: 0,
        isLoading: false,
        minLoadedTime: null,
        maxLoadedTime: null
    };

    function updateEnergySeparationChart(extendDays = null) {
        const selectEl = document.getElementById('separation-days-select');
        const days = extendDays || parseInt(selectEl.value);
        const chartDiv = document.getElementById('separation-chart');
        const summaryDiv = document.getElementById('separation-summary');

        if (!extendDays) {
            chartDiv.innerHTML = '<div class="loading-spinner">Loading energy separation data...</div>';
            summaryDiv.innerHTML = '';
        }
        separationState.isLoading = true;

        fetch(`/api/house/${houseId}/energy-separated?days=${days}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                separationState.isLoading = false;
                const data = result.data || [];
                const totals = result.totals || {};
                const kValue = result.k_value;

                if (data.length === 0 && !extendDays) {
                    chartDiv.innerHTML = '<div class="no-data-message">No energy separation data available. Run the calibrator first:<br><code>python heating_energy_calibrator.py --house ' + houseId + ' --write</code></div>';
                    return;
                }

                // Update state
                separationState.loadedDays = days;
                if (data.length > 0) {
                    separationState.minLoadedTime = new Date(data[0].timestamp);
                    separationState.maxLoadedTime = new Date(data[data.length - 1].timestamp);
                }

                const timestamps = data.map(d => d.timestamp_display);

                // Stacked bar chart: Heating (bottom) + DHW (top)
                const traces = [
                    {
                        x: timestamps,
                        y: data.map(d => d.heating_kwh),
                        type: 'bar',
                        name: 'Heating',
                        marker: { color: '#3498db' },
                        hovertemplate: '%{x}<br>Heating: %{y} kWh<extra></extra>'
                    },
                    {
                        x: timestamps,
                        y: data.map(d => d.dhw_kwh),
                        type: 'bar',
                        name: 'Hot Water (DHW)',
                        marker: { color: '#e67e22' },
                        hovertemplate: '%{x}<br>Hot Water: %{y} kWh<extra></extra>'
                    }
                ];

                // Add markers for actual consumption (no line, just hover info)
                traces.push({
                    x: timestamps,
                    y: data.map(d => d.actual_kwh),
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Actual Total',
                    marker: { color: '#2c3e50', size: 8, symbol: 'diamond' },
                    hovertemplate: '%{x}<br>Actual: %{y} kWh<extra></extra>'
                });

                const layout = {
                    xaxis: {
                        title: 'Date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        tickangle: -45
                    },
                    yaxis: {
                        title: 'Energy (kWh)',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        rangemode: 'tozero'
                    },
                    barmode: 'stack',
                    height: 400,
                    margin: { l: 60, r: 30, t: 30, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: {
                        orientation: 'h',
                        yanchor: 'bottom',
                        y: 1.02,
                        xanchor: 'right',
                        x: 1
                    },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                if (!extendDays) {
                    chartDiv.innerHTML = '';
                }

                const plotFn = extendDays ? Plotly.react : Plotly.newPlot;
                plotFn('separation-chart', traces, layout, chartConfig)
                    .then(() => {
                        if (!extendDays) {
                            document.getElementById('separation-chart').on('plotly_relayout', (e) => handleChartPanDays(e, separationState, 'separation-days-select', updateEnergySeparationChart));
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        if (!extendDays) chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });

                // Update summary
                if (!extendDays) {
                    const kDisplay = kValue ? `${kValue} kW/°C` : 'N/A';
                    summaryDiv.innerHTML = `
                        <div class="metric-item">
                            <div class="metric-value">${totals.actual || 0} kWh</div>
                            <div class="metric-label">Total Consumption</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" style="color: #3498db">${totals.heating || 0} kWh</div>
                            <div class="metric-label">Heating (${totals.heating_pct || 0}%)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" style="color: #e67e22">${totals.dhw || 0} kWh</div>
                            <div class="metric-label">Hot Water (${totals.dhw_pct || 0}%)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" style="color: #7f8c8d; font-size: 1.2em">${kDisplay}</div>
                            <div class="metric-label">Heat Loss Coeff (k)</div>
                        </div>
                    `;
                }
            })
            .catch(error => {
                separationState.isLoading = false;
                console.error('Failed to load energy separation data:', error);
                if (!extendDays) chartDiv.innerHTML = '<div class="no-data-message">Failed to load energy separation data.</div>';
            });
    }

    // K-Value History Chart
    function updateKValueChart() {
        const selectEl = document.getElementById('k-history-days-select');
        const days = parseInt(selectEl.value);
        const chartDiv = document.getElementById('k-value-chart');
        const summaryDiv = document.getElementById('k-value-summary');

        chartDiv.innerHTML = '<div class="loading-spinner">Loading k-value history...</div>';
        summaryDiv.innerHTML = '';

        fetch(`/api/house/${houseId}/k-value-history?days=${days}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                const data = result.data || [];
                const currentK = result.current_k;

                if (data.length === 0) {
                    chartDiv.innerHTML = '<div class="no-data-message">No k-value history yet. Recalibration runs every 72 hours.</div>';
                    return;
                }

                const timestamps = data.map(d => d.timestamp_display);
                const kValues = data.map(d => d.k_value);
                const kMedians = data.map(d => d.k_median);
                const kStddevUpper = data.map(d => d.k_median + d.k_stddev);
                const kStddevLower = data.map(d => d.k_median - d.k_stddev);

                const traces = [
                    // Stddev band (shaded area)
                    {
                        x: timestamps.concat(timestamps.slice().reverse()),
                        y: kStddevUpper.concat(kStddevLower.slice().reverse()),
                        fill: 'toself',
                        fillcolor: 'rgba(52, 152, 219, 0.15)',
                        line: { color: 'transparent' },
                        name: '±1 Std Dev',
                        showlegend: true,
                        hoverinfo: 'skip'
                    },
                    // K-value (15th percentile) - main line
                    {
                        x: timestamps,
                        y: kValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'k (15th pct)',
                        line: { color: '#e74c3c', width: 3 },
                        marker: {
                            size: data.map((_, i) => i === data.length - 1 ? 12 : 6),
                            color: '#e74c3c'
                        },
                        hovertemplate: '%{x}<br>k: %{y:.4f} kW/°C<extra></extra>'
                    },
                    // K-median line
                    {
                        x: timestamps,
                        y: kMedians,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'k (median)',
                        line: { color: '#3498db', width: 2, dash: 'dash' },
                        hovertemplate: '%{x}<br>Median: %{y:.4f} kW/°C<extra></extra>'
                    }
                ];

                const layout = {
                    xaxis: {
                        title: '',
                        tickangle: -45,
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)'
                    },
                    yaxis: {
                        title: 'k (kW/°C)',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        rangemode: 'tozero'
                    },
                    height: 350,
                    margin: { l: 60, r: 30, t: 30, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: {
                        orientation: 'h',
                        yanchor: 'bottom',
                        y: 1.02,
                        xanchor: 'right',
                        x: 1
                    },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                // Clear loading spinner before rendering chart
                chartDiv.innerHTML = '';

                Plotly.newPlot('k-value-chart', traces, layout, chartConfig)
                    .then(() => {
                        // Update summary with latest values
                        const latest = data[data.length - 1];
                        const change = data.length > 1 ? (latest.k_value - data[0].k_value) : 0;
                        const changeStr = change >= 0 ? `+${(change * 1000).toFixed(2)}` : `${(change * 1000).toFixed(2)}`;
                        const changeColor = Math.abs(change) < 0.005 ? '#27ae60' : '#e67e22';  // Green if stable

                        summaryDiv.innerHTML = `
                            <div class="metric-item">
                                <div class="metric-value" style="color: #e74c3c">${latest.k_value.toFixed(4)} kW/°C</div>
                                <div class="metric-label">Current k (15th pct)</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" style="color: #3498db">${latest.k_median.toFixed(4)} kW/°C</div>
                                <div class="metric-label">Median k</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" style="color: ${changeColor}">${changeStr}</div>
                                <div class="metric-label">Change (×10⁻³)</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value">${(latest.confidence * 100).toFixed(0)}%</div>
                                <div class="metric-label">Confidence</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value">${latest.days_used} days</div>
                                <div class="metric-label">Data Points</div>
                            </div>
                        `;
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });
            })
            .catch(error => {
                console.error('Failed to load k-value history:', error);
                chartDiv.innerHTML = '<div class="no-data-message">Failed to load k-value history.</div>';
            });
    }

    // Initialize all charts on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Existing charts
        if (document.getElementById('availability-chart')) {
            renderChart(initialData);
        }
        updateEffectiveTempChart();

        // New charts - load with slight delay to not overload
        setTimeout(() => updateTemperatureHistoryChart(), 100);
        setTimeout(() => updateEfficiencyChart(), 200);
        setTimeout(() => updateEnergySeparationChart(), 300);
        setTimeout(() => updateKValueChart(), 400);
        setTimeout(() => updateCostChart(), 500);
    });
</script>
{% endblock %}
