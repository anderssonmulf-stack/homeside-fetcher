{% extends "base.html" %}
{% block title %}Graphs - {{ friendly_name }}{% endblock %}

{% block content %}
<div class="house-detail">
    <div class="page-header">
        {% if is_aggregate %}
        <a href="{{ url_for('dashboard') }}" class="back-link">&larr; Back to Dashboard</a>
        <h1 class="friendly-name">üèòÔ∏è All Houses - Aggregated View</h1>
        <p class="subtitle">Combined energy data across all houses</p>
        {% else %}
        <a href="{{ url_for('house_detail', house_id=house_id) }}" class="back-link">&larr; Back to {{ friendly_name }}</a>
        <h1 class="friendly-name">Data Overview</h1>
        <p class="subtitle">{{ friendly_name }}</p>
        {% endif %}
    </div>

    <!-- Current Status Widgets -->
    {% if not is_aggregate %}
    <div class="status-widgets">
        {% if realtime %}
        <div class="stat-widget">
            <div class="stat-value {% if realtime.room_temperature and realtime.room_temperature >= 21 and realtime.room_temperature <= 24 %}good{% elif realtime.room_temperature and realtime.room_temperature > 24 %}warm{% else %}cold{% endif %}">
                {{ "%.1f"|format(realtime.room_temperature) if realtime.room_temperature else '--' }}¬∞C
            </div>
            <div class="stat-label">Room</div>
        </div>
        <div class="stat-widget">
            <div class="stat-value neutral">
                {{ "%.1f"|format(realtime.target_temp_setpoint) if realtime.target_temp_setpoint else '--' }}¬∞C
            </div>
            <div class="stat-label">Target</div>
        </div>
        <div class="stat-widget">
            <div class="stat-value {% if realtime.outdoor_temperature and realtime.outdoor_temperature >= 5 %}mild{% elif realtime.outdoor_temperature and realtime.outdoor_temperature >= 0 %}cool{% else %}cold{% endif %}">
                {{ "%.1f"|format(realtime.outdoor_temperature) if realtime.outdoor_temperature else '--' }}¬∞C
            </div>
            <div class="stat-label">Outdoor</div>
        </div>
        <div class="stat-widget">
            <div class="stat-value {% if realtime.supply_temp and realtime.supply_temp >= 25 and realtime.supply_temp <= 40 %}good{% elif realtime.supply_temp and realtime.supply_temp > 40 %}warm{% else %}neutral{% endif %}">
                {{ "%.1f"|format(realtime.supply_temp) if realtime.supply_temp else '--' }}¬∞C
            </div>
            <div class="stat-label">Supply</div>
        </div>
        <div class="stat-widget">
            <div class="stat-value {% if realtime.hot_water_temp and realtime.hot_water_temp >= 50 %}good{% elif realtime.hot_water_temp and realtime.hot_water_temp >= 40 %}warm{% else %}cold{% endif %}">
                {{ "%.1f"|format(realtime.hot_water_temp) if realtime.hot_water_temp else '--' }}¬∞C
            </div>
            <div class="stat-label">Hot Water</div>
        </div>
        <div class="stat-widget">
            <div class="stat-value {% if realtime.system_pressure and realtime.system_pressure >= 0.5 and realtime.system_pressure <= 1.5 %}good{% elif realtime.system_pressure and realtime.system_pressure < 0.5 %}cold{% else %}warm{% endif %}">
                {{ "%.2f"|format(realtime.system_pressure) if realtime.system_pressure else '--' }} bar
            </div>
            <div class="stat-label">Pressure</div>
        </div>
        {% else %}
        <div class="stat-widget wide">
            <div class="stat-value neutral">No data</div>
            <div class="stat-label">Heating system offline</div>
        </div>
        {% endif %}
    </div>
    {% if realtime and realtime.timestamp_friendly %}
    <p class="status-timestamp {% if realtime.age_minutes and realtime.age_minutes <= 16 %}fresh{% else %}stale{% endif %}">
        Last updated: {{ realtime.timestamp_friendly }}
        {% if realtime.age_minutes %}({{ realtime.age_minutes|int }} min ago){% endif %}
    </p>
    {% endif %}
    {% endif %}{# end not is_aggregate #}

    {% if not is_aggregate %}
    <!-- Supply & Return Temperatures & Forecast Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Supply & Return Temperatures & Forecast</h2>
            <div class="chart-controls">
                <select id="supply-return-days-select" class="role-select" onchange="updateSupplyReturnChart()">
                    <option value="24">Last 24 hours</option>
                    <option value="72">Last 3 days</option>
                    <option value="168" selected>Last 7 days</option>
                    <option value="336">Last 14 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Supply and return water temperatures with heat curve comparison.
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color supply-temp"></span> Supply</span>
                <span class="legend-item"><span class="legend-color return-temp"></span> Return</span>
                <span class="legend-item"><span class="legend-color heat-curve"></span> Heat Curve</span>
                <span class="legend-item"><span class="legend-color heat-curve-ml"></span> Heat Curve (ML)</span>
            </span>
        </p>
        <div id="supply-return-chart" class="chart-container"></div>
    </div>

    <!-- Data Availability Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Data Availability</h2>
            <div class="chart-controls">
                <select id="days-select" class="role-select" onchange="updateChart()">
                    <option value="7">Last 7 days</option>
                    <option value="30" selected>Last 30 days</option>
                    <option value="90">Last 90 days</option>
                    <option value="365">Last year</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Shows data coverage per category. Darker blue = more data points.
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color predicted"></span> * = Predicted data</span>
            </span>
        </p>

        {% if availability.categories %}
        <div id="availability-chart" class="chart-container"></div>
        {% else %}
        <p class="muted">No data available for this house yet.</p>
        {% endif %}
    </div>

    <!-- Effective Temperature Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Effective Outdoor Temperature</h2>
            <div class="chart-controls">
                <select id="eff-temp-days-select" class="role-select" onchange="updateEffectiveTempChart()">
                    <option value="24">Last 24 hours</option>
                    <option value="72">Last 3 days</option>
                    <option value="168" selected>Last 7 days</option>
                    <option value="336">Last 14 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Compares actual outdoor temperature with "effective" temperature
            that accounts for wind chill, humidity, and solar effects.
            <strong>Dotted</strong> = effective temp. <strong>Dashed</strong> = 12h forecast.
        </p>
        <div id="effective-temp-chart" class="chart-container"></div>
    </div>

    <!-- Effect Breakdown Chart -->
    <div class="card">
        <h2>Weather Effect Breakdown</h2>
        <p class="card-description">
            Shows how wind, humidity, and solar radiation affect the effective temperature.
            Negative values = colder, Positive = warmer.
        </p>
        <div id="effect-breakdown-chart" class="chart-container"></div>
    </div>

    <!-- Primary vs Secondary Temperature Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Primary vs Secondary Temperatures</h2>
            <div class="chart-controls">
                <select id="temp-history-days-select" class="role-select" onchange="updateTemperatureHistoryChart()">
                    <option value="24">Last 24 hours</option>
                    <option value="72">Last 3 days</option>
                    <option value="168" selected>Last 7 days</option>
                    <option value="336">Last 14 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Compares <strong>District Heating</strong> (primary side from utility) with
            <strong>House Heating</strong> (secondary side to radiators).
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color dh-supply"></span> DH Supply</span>
                <span class="legend-item"><span class="legend-color dh-return"></span> DH Return</span>
                <span class="legend-item"><span class="legend-color house-supply"></span> House Supply</span>
                <span class="legend-item"><span class="legend-color house-return"></span> House Return</span>
                <span class="legend-item"><span class="legend-color" style="background: #9b59b6;"></span> Predicted Supply</span>
            </span>
        </p>
        <div id="temp-history-chart" class="chart-container"></div>
    </div>

    <!-- Efficiency Metrics Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Efficiency Metrics (Delta T)</h2>
            <div class="chart-controls">
                <select id="efficiency-days-select" class="role-select" onchange="updateEfficiencyChart()">
                    <option value="24">Last 24 hours</option>
                    <option value="72">Last 3 days</option>
                    <option value="168" selected>Last 7 days</option>
                    <option value="336">Last 14 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            <strong>Delta T</strong> shows temperature difference between supply and return.
            Higher DH delta T = more heat extracted from district heating.
            Good values: DH 25-40¬∞C, House 5-15¬∞C.
        </p>
        <div id="efficiency-chart" class="chart-container"></div>
        <div id="efficiency-summary" class="metric-summary"></div>
    </div>

    <!-- Real-Time Power & Flow Chart (MBus meter, if available) -->
    <div class="card" id="realtime-power-card" style="display: none;">
        <div class="card-header-flex">
            <h2>Real-Time Power & Flow (MBus)</h2>
            <div class="chart-controls">
                <select id="realtime-power-days-select" class="role-select" onchange="updateRealtimePowerChart()">
                    <option value="24">Last 24 hours</option>
                    <option value="72">Last 3 days</option>
                    <option value="168" selected>Last 7 days</option>
                    <option value="336">Last 14 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Instantaneous power and flow from the MBus energy meter, sampled every 5 minutes.
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color" style="background: #e74c3c;"></span> Power (kW)</span>
                <span class="legend-item"><span class="legend-color" style="background: #3498db;"></span> Flow (l/h)</span>
            </span>
        </p>
        <div id="realtime-power-chart" class="chart-container"></div>
    </div>
    {% endif %}{# end not is_aggregate for per-house charts #}

    <!-- Energy Forecast Chart (24h ahead) -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Energy Forecast (Next 24h)</h2>
            <div class="chart-controls">
                <select id="energy-forecast-hours-select" class="role-select" onchange="updateEnergyForecastChart()">
                    <option value="12">Next 12h</option>
                    <option value="24" selected>Next 24h</option>
                    <option value="48">Next 48h</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Predicted <strong>hourly heating energy</strong> based on weather forecast and learned building model.
            Uses ML2 calibrated coefficients for accurate solar/wind effects.
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color" style="background:#FF6B6B;"></span> Energy (kWh/h)</span>
                <span class="legend-item"><span class="legend-color" style="background:#4ECDC4; opacity:0.5;"></span> Outdoor Temp</span>
            </span>
        </p>
        <div id="energy-forecast-chart" class="chart-container"></div>
        <div id="energy-forecast-summary" class="metric-summary"></div>
    </div>

    {% if is_aggregate %}
    <!-- Flexibility Chart (aggregate only) -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Flexibility</h2>
            <div class="chart-controls">
                <select id="flexibility-hours-select" class="role-select" onchange="updateFlexibilityChart()">
                    <option value="12">Next 12h</option>
                    <option value="24" selected>Next 24h</option>
                    <option value="48">Next 48h</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Potential to <strong>reduce heating</strong> based on outdoor temperature trend.
            <strong style="color:#27ae60;">Green</strong> = temperature rising (safe to cut).
            <strong style="color:#e74c3c;">Red</strong> = temperature dropping (avoid cutting).
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color" style="background:#27ae60;"></span> Rising (+2¬∞C/h)</span>
                <span class="legend-item"><span class="legend-color" style="background:#f1c40f;"></span> Stable (0¬∞C/h)</span>
                <span class="legend-item"><span class="legend-color" style="background:#e74c3c;"></span> Dropping (-2¬∞C/h)</span>
            </span>
        </p>
        <div id="flexibility-chart" class="chart-container"></div>
        <div id="flexibility-summary" class="metric-summary"></div>
    </div>
    {% endif %}

    <!-- Energy Separation Chart (Heating vs DHW) -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Energy Breakdown (Heating vs Hot Water)</h2>
            <div class="chart-controls">
                <select id="separation-days-select" class="role-select" onchange="updateEnergySeparationChart()">
                    <option value="7">Last 7 days</option>
                    <option value="30" selected>Last 30 days</option>
                    <option value="90">Last 90 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Separates total energy into <strong>space heating</strong> and <strong>domestic hot water (DHW)</strong>
            using calibrated building heat loss model. <strong>Dashed line</strong> shows predicted heating.
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color heating-energy"></span> Heating</span>
                <span class="legend-item"><span class="legend-color dhw-energy"></span> Hot Water</span>
                <span class="legend-item"><span class="legend-color" style="background:#9b59b6;"></span> Predicted</span>
            </span>
        </p>
        <div id="separation-chart" class="chart-container"></div>
        <div id="separation-summary" class="metric-summary"></div>
    </div>

    {% if not is_aggregate %}
    <!-- Prediction Accuracy Trend Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Prediction Accuracy Trend</h2>
            <div class="chart-controls">
                <select id="accuracy-days-select" class="role-select" onchange="updateAccuracyChart()">
                    <option value="7">Last 7 days</option>
                    <option value="30" selected>Last 30 days</option>
                    <option value="90">Last 90 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Daily prediction accuracy: <strong>predicted heating √∑ actual heating √ó 100%</strong>.
            Green zone (90‚Äì110%) indicates good model fit.
            <span class="legend-inline">
                <span class="legend-item"><span class="legend-color" style="background:#27ae60;"></span> Good (90‚Äì110%)</span>
                <span class="legend-item"><span class="legend-color" style="background:#f39c12;"></span> Fair (80‚Äì120%)</span>
                <span class="legend-item"><span class="legend-color" style="background:#e74c3c;"></span> Poor</span>
            </span>
        </p>
        <div id="accuracy-chart" class="chart-container"></div>
        <div id="accuracy-summary" class="metric-summary"></div>
    </div>

    <!-- Energy Signature Plot -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Energy Signature</h2>
            <div class="chart-controls" style="display: flex; gap: 8px; align-items: center;">
                <div class="btn-group" style="display: inline-flex; border: 1px solid #ddd; border-radius: 6px; overflow: hidden;">
                    <button type="button" class="sig-res-btn" data-res="hour" onclick="switchSignatureResolution('hour')" style="padding: 4px 10px; border: none; background: #fff; cursor: pointer; font-size: 0.85em; border-right: 1px solid #ddd;">Hour</button>
                    <button type="button" class="sig-res-btn active" data-res="day" onclick="switchSignatureResolution('day')" style="padding: 4px 10px; border: none; background: #3498db; color: #fff; cursor: pointer; font-size: 0.85em; border-right: 1px solid #ddd;">Day</button>
                    <button type="button" class="sig-res-btn" data-res="month" onclick="switchSignatureResolution('month')" style="padding: 4px 10px; border: none; background: #fff; cursor: pointer; font-size: 0.85em;">Month</button>
                </div>
                <select id="signature-days-select" class="role-select" onchange="updateSignatureChart()">
                    <option value="30">Last 30 days</option>
                    <option value="90" selected>Last 90 days</option>
                    <option value="180">Last 180 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Industry-standard plot of <strong>energy vs outdoor temperature</strong>.
            The regression slope gives an independent estimate of the building's heat loss coefficient (k).
            Switch resolution to see hourly, daily, or monthly aggregation.
        </p>
        <div id="signature-chart" class="chart-container"></div>
        <div id="signature-summary" class="metric-summary"></div>
    </div>

    <!-- K-Value History Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Heat Loss Coefficient (k) History</h2>
            <div class="chart-controls">
                <select id="k-history-days-select" class="role-select" onchange="updateKValueChart()">
                    <option value="7">Last 7 days</option>
                    <option value="30" selected>Last 30 days</option>
                    <option value="90">Last 90 days</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Shows how the building's heat loss coefficient (k) converges over time.
            When the line flattens, the calibration has stabilized.
            <strong>k = kW per ¬∞C difference</strong> between indoor and outdoor temperature.
        </p>
        <div id="k-value-chart" class="chart-container"></div>
        <div id="k-value-summary" class="metric-summary"></div>
    </div>

    <!-- Cost Estimate Chart -->
    <div class="card">
        <div class="card-header-flex">
            <h2>Cost Estimate<span id="cost-data-source" class="data-source-badge" style="display:none;"></span></h2>
            <div class="chart-controls">
                <label class="price-label">
                    Price (SEK/kWh):
                    <input type="number" id="price-input" class="price-input" value="1.20" step="0.01" min="0" onchange="updateCostChart()">
                </label>
                <select id="cost-days-select" class="role-select" onchange="updateCostChart()">
                    <option value="7">Last 7 days</option>
                    <option value="30" selected>Last 30 days</option>
                    <option value="90">Last 90 days</option>
                    <option value="365">Last year</option>
                </select>
            </div>
        </div>
        <p class="card-description">
            Estimated heating costs based on energy consumption and price per kWh.
            Default price is typical Swedish district heating rate.
        </p>
        <div id="cost-chart" class="chart-container"></div>
        <div id="cost-summary" class="cost-summary-box"></div>
    </div>
    {% endif %}{# end not is_aggregate for remaining charts #}
</div>

<style>
/* Status Widgets */
.status-widgets {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-bottom: 8px;
}
.stat-widget {
    background: var(--white, #fff);
    border-radius: 8px;
    padding: 16px 20px;
    min-width: 100px;
    flex: 1;
    text-align: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.stat-widget.wide {
    flex: 2;
    min-width: 200px;
}
.stat-value {
    font-size: 1.8em;
    font-weight: 600;
    line-height: 1.2;
}
.stat-value.good { color: #27ae60; }
.stat-value.warm { color: #e67e22; }
.stat-value.cold { color: #3498db; }
.stat-value.mild { color: #27ae60; }
.stat-value.cool { color: #3498db; }
.stat-value.neutral { color: var(--text-color, #333); }
.stat-label {
    font-size: 0.85em;
    color: var(--muted, #7f8c8d);
    margin-top: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.status-timestamp {
    font-size: 0.85em;
    color: var(--muted);
    text-align: right;
    margin-bottom: 20px;
}
.status-timestamp.fresh { color: #27ae60; }
.status-timestamp.stale { color: #e67e22; }

.card-header-flex {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}
.card-header-flex h2 {
    margin: 0;
}
.chart-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}
.chart-container {
    width: 100%;
    min-height: 300px;
}
.legend-inline {
    display: inline-flex;
    gap: 15px;
    margin-left: 10px;
}
.legend-item {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    font-size: 0.85em;
    color: var(--muted);
}
.legend-color {
    width: 12px;
    height: 12px;
    border-radius: 2px;
}
.legend-color.measured {
    background: #3498db;
}
.legend-color.predicted {
    background: #9b59b6;
}
.feature-list {
    margin: 15px 0;
    padding-left: 20px;
}
.feature-list li {
    margin: 8px 0;
    color: var(--muted);
}
.loading-spinner {
    padding: 40px;
    text-align: center;
    color: var(--muted);
    font-style: italic;
}
/* Data source badges */
.data-source-badge {
    display: inline-block;
    font-size: 0.7rem;
    font-weight: 600;
    padding: 3px 8px;
    border-radius: 4px;
    margin-left: 10px;
    vertical-align: middle;
    text-transform: uppercase;
}
.data-source-badge.live {
    background: #27ae60;
    color: white;
}
.data-source-badge.imported {
    background: #3498db;
    color: white;
}
/* Temperature legend colors */
.legend-color.dh-supply {
    background: #e74c3c;
}
.legend-color.dh-return {
    background: #c0392b;
}
.legend-color.house-supply {
    background: #3498db;
}
.legend-color.house-return {
    background: #2980b9;
}
.legend-color.heating-energy {
    background: #3498db;
}
.legend-color.dhw-energy {
    background: #e67e22;
}
/* Supply/Return chart colors */
.legend-color.supply-temp {
    background: #e74c3c;
}
.legend-color.return-temp {
    background: #3498db;
}
.legend-color.heat-curve {
    background: #27ae60;
}
.legend-color.heat-curve-ml {
    background: #9b59b6;
}
/* Metric summary boxes */
.metric-summary {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    margin-top: 15px;
    padding: 15px;
    background: var(--card-bg, #f8f9fa);
    border-radius: 8px;
}
.metric-item {
    text-align: center;
    min-width: 100px;
}
.metric-value {
    font-size: 1.5em;
    font-weight: 600;
    color: var(--primary, #3498db);
}
.metric-label {
    font-size: 0.85em;
    color: var(--muted);
    margin-top: 4px;
}
/* Cost summary box */
.cost-summary-box {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
    margin-top: 15px;
    padding: 20px;
    background: linear-gradient(135deg, #e8f4fd 0%, #d4edda 100%);
    border-radius: 8px;
}
.cost-item {
    text-align: center;
}
.cost-item.highlight {
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.cost-value {
    font-size: 1.8em;
    font-weight: 700;
    color: #27ae60;
}
.cost-value.projection {
    color: #2980b9;
}
.cost-label {
    font-size: 0.85em;
    color: var(--muted);
    margin-top: 4px;
}
/* Price input styling */
.price-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9em;
    color: var(--muted);
}
.price-input {
    width: 70px;
    padding: 4px 8px;
    border: 1px solid var(--border, #ddd);
    border-radius: 4px;
    font-size: 0.9em;
}
/* No data message */
.no-data-message {
    padding: 40px;
    text-align: center;
    color: var(--muted);
    font-style: italic;
    background: var(--card-bg, #f8f9fa);
    border-radius: 8px;
}
</style>

<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script>
    const houseId = "{{ house_id }}";
    const isAggregate = {{ 'true' if is_aggregate else 'false' }};
    let currentChart = null;

    // Initial chart data from server
    const initialData = {{ graph_json | safe }};
    const chartConfig = {{ config_json | safe }};

    function renderChart(data) {
        Plotly.newPlot('availability-chart', data.data, data.layout, chartConfig);
    }

    // Supply & Return Temperatures with Forecast Chart
    function updateSupplyReturnChart() {
        const hours = document.getElementById('supply-return-days-select').value;
        const chartDiv = document.getElementById('supply-return-chart');

        chartDiv.innerHTML = '<div class="loading-spinner">Loading supply/return data...</div>';

        fetch(`/api/house/${houseId}/supply-return-forecast?hours=${hours}`)
            .then(r => r.ok ? r.json() : { history: [], forecast: [] })
            .then(result => {
                const history = result.history || [];
                const forecast = result.forecast || [];

                if (history.length === 0) {
                    chartDiv.innerHTML = '<div class="no-data-message">No supply/return temperature data available.</div>';
                    return;
                }

                const histTimestamps = history.map(d => d.timestamp_display);
                const forecastTimestamps = forecast.map(d => d.timestamp_display);

                // Get current time for "now" line
                const nowTime = histTimestamps.length > 0 ? histTimestamps[histTimestamps.length - 1] : null;

                const traces = [
                    // Supply Temperature (solid red)
                    {
                        x: histTimestamps,
                        y: history.map(d => d.supply_temp),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Supply',
                        line: { color: '#e74c3c', width: 2 },
                        hovertemplate: '%{x}<br>Supply: %{y}¬∞C<extra></extra>'
                    },
                    // Return Temperature (solid blue)
                    {
                        x: histTimestamps,
                        y: history.map(d => d.return_temp),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Return',
                        line: { color: '#3498db', width: 2 },
                        hovertemplate: '%{x}<br>Return: %{y}¬∞C<extra></extra>'
                    },
                    // Heat Curve (baseline - dashed green)
                    {
                        x: histTimestamps,
                        y: history.map(d => d.heat_curve),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Heat Curve',
                        line: { color: '#27ae60', width: 2, dash: 'dash' },
                        hovertemplate: '%{x}<br>Heat Curve: %{y}¬∞C<extra></extra>'
                    },
                    // Heat Curve ML (dotted purple)
                    {
                        x: histTimestamps,
                        y: history.map(d => d.heat_curve_ml),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Heat Curve (ML)',
                        line: { color: '#9b59b6', width: 2, dash: 'dot' },
                        hovertemplate: '%{x}<br>Heat Curve ML: %{y}¬∞C<extra></extra>'
                    }
                ];

                // Add forecast traces if available
                if (forecast.length > 0) {
                    traces.push(
                        {
                            x: forecastTimestamps,
                            y: forecast.map(d => d.supply_baseline),
                            type: 'scatter',
                            mode: 'lines',
                            name: 'Forecast (Baseline)',
                            line: { color: '#27ae60', width: 2, dash: 'dashdot' },
                            hovertemplate: '%{x}<br>Forecast: %{y}¬∞C<extra></extra>'
                        },
                        {
                            x: forecastTimestamps,
                            y: forecast.map(d => d.supply_ml),
                            type: 'scatter',
                            mode: 'lines',
                            name: 'Forecast (ML)',
                            line: { color: '#9b59b6', width: 2, dash: 'dashdot' },
                            hovertemplate: '%{x}<br>Forecast ML: %{y}¬∞C<extra></extra>'
                        }
                    );
                }

                const layout = {
                    xaxis: {
                        title: 'Time',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)'
                    },
                    yaxis: {
                        title: 'Temperature (¬∞C)',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)'
                    },
                    height: 400,
                    margin: { l: 60, r: 30, t: 30, b: 60 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: {
                        orientation: 'h',
                        yanchor: 'bottom',
                        y: 1.02,
                        xanchor: 'right',
                        x: 1
                    },
                    dragmode: 'pan',
                    hovermode: 'x unified',
                    // Add vertical "now" line if we have forecast data
                    shapes: (nowTime && forecast.length > 0) ? [{
                        type: 'line',
                        x0: nowTime,
                        x1: nowTime,
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: { color: 'rgba(0,0,0,0.3)', width: 2, dash: 'dot' }
                    }] : [],
                    annotations: (nowTime && forecast.length > 0) ? [{
                        x: nowTime,
                        y: 1,
                        yref: 'paper',
                        text: 'Now',
                        showarrow: false,
                        font: { size: 10, color: 'rgba(0,0,0,0.5)' },
                        yanchor: 'bottom'
                    }] : []
                };

                chartDiv.innerHTML = '';

                Plotly.newPlot('supply-return-chart', traces, layout, chartConfig)
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });
            })
            .catch(error => {
                console.error('Failed to load supply/return data:', error);
                chartDiv.innerHTML = '<div class="no-data-message">Failed to load supply/return data.</div>';
            });
    }

    // Helper function to update data source badge
    function updateDataSourceBadge(elementId, dataSource) {
        const badge = document.getElementById(elementId);
        if (!badge) return;

        if (dataSource === 'live') {
            badge.textContent = 'Live Data';
            badge.className = 'data-source-badge live';
            badge.style.display = 'inline-block';
        } else if (dataSource === 'imported') {
            badge.textContent = 'Imported Data';
            badge.className = 'data-source-badge imported';
            badge.style.display = 'inline-block';
        } else {
            badge.style.display = 'none';
        }
    }

    function updateChart() {
        const days = document.getElementById('days-select').value;
        const chartDiv = document.getElementById('availability-chart');

        // Show loading state
        chartDiv.style.opacity = '0.5';

        fetch(`/api/house/${houseId}/data-availability?days=${days}`)
            .then(response => response.json())
            .then(availability => {
                if (!availability.categories || availability.categories.length === 0) {
                    chartDiv.innerHTML = '<p class="muted">No data available.</p>';
                    chartDiv.style.opacity = '1';
                    return;
                }

                // Collect all unique dates
                const allDatesSet = new Set();
                availability.categories.forEach(cat => {
                    cat.data.forEach(d => allDatesSet.add(d.date));
                });
                const allDates = Array.from(allDatesSet).sort();

                // Build heatmap data
                const categoryNames = availability.categories.map(c => c.name);
                const zValues = availability.categories.map(cat => {
                    const dateToCount = {};
                    cat.data.forEach(d => { dateToCount[d.date] = d.count; });
                    return allDates.map(date => dateToCount[date] || 0);
                });

                const traces = [{
                    z: zValues,
                    x: allDates,
                    y: categoryNames,
                    type: 'heatmap',
                    colorscale: [
                        [0, '#f8f9fa'],
                        [0.01, '#e3f2fd'],
                        [0.25, '#90caf9'],
                        [0.5, '#42a5f5'],
                        [1, '#1565c0']
                    ],
                    showscale: true,
                    colorbar: {
                        title: { text: 'Data points', side: 'right' }
                    },
                    hovertemplate: '%{x}<br>%{y}: %{z} points<extra></extra>'
                }];

                const layout = {
                    xaxis: {
                        title: 'Date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        tickangle: -45
                    },
                    yaxis: {
                        title: null,
                        autorange: 'reversed'
                    },
                    height: Math.max(300, availability.categories.length * 40 + 150),
                    margin: { l: 130, r: 80, t: 20, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    dragmode: 'pan'
                };

                Plotly.react('availability-chart', traces, layout, chartConfig);
                chartDiv.style.opacity = '1';
            })
            .catch(error => {
                console.error('Failed to update chart:', error);
                chartDiv.style.opacity = '1';
            });
    }

    // Effective Temperature Chart (with forecast)
    // Insert null entries into data array where time gaps > maxGapMs exist.
    // This makes Plotly break lines at gaps instead of drawing straight lines across them.
    // Returns new array with null-valued entries inserted at gap midpoints.
    function insertGapNulls(data, timestampKey, maxGapMs) {
        if (!data || data.length < 2) return data;
        const result = [];
        for (let i = 0; i < data.length; i++) {
            result.push(data[i]);
            if (i < data.length - 1) {
                const t1 = new Date(data[i][timestampKey]).getTime();
                const t2 = new Date(data[i + 1][timestampKey]).getTime();
                if (!isNaN(t1) && !isNaN(t2) && t2 - t1 > maxGapMs) {
                    // Create a null entry with a midpoint display timestamp
                    const midTime = new Date((t1 + t2) / 2);
                    const pad = n => String(n).padStart(2, '0');
                    const midDisplay = `${midTime.getFullYear()}-${pad(midTime.getMonth()+1)}-${pad(midTime.getDate())} ${pad(midTime.getHours())}:${pad(midTime.getMinutes())}`;
                    const nullEntry = {};
                    for (const key of Object.keys(data[i])) {
                        nullEntry[key] = null;
                    }
                    nullEntry['timestamp_display'] = midDisplay;
                    nullEntry['timestamp'] = midTime.toISOString();
                    result.push(nullEntry);
                }
            }
        }
        return result;
    }

    function updateEffectiveTempChart() {
        const hours = document.getElementById('eff-temp-days-select').value;
        const chartDiv = document.getElementById('effective-temp-chart');
        const breakdownDiv = document.getElementById('effect-breakdown-chart');

        console.log(`Fetching effective temp for house=${houseId}, hours=${hours}`);

        const historyUrl = `/api/house/${houseId}/effective-temperature?hours=${hours}`;
        const forecastUrl = `/api/house/${houseId}/forecast-effective-temperature?hours=12`;
        const histForecastUrl = `/api/house/${houseId}/historical-forecast-effective-temperature?hours=${hours}`;

        // Fetch historical, forecast, and historical forecast data in parallel
        Promise.all([
            fetch(historyUrl).then(r => r.ok ? r.json() : { data: [] }),
            fetch(forecastUrl).then(r => r.ok ? r.json() : { data: [] }),
            fetch(histForecastUrl).then(r => r.ok ? r.json() : { data: [] })
        ])
        .then(([historyResult, forecastResult, histForecastResult]) => {
            console.log('History data:', historyResult.data?.length || 0, 'points');
            console.log('Forecast data:', forecastResult.data?.length || 0, 'points');
            console.log('Hist forecast data:', histForecastResult.data?.length || 0, 'points');

            // Insert nulls at time gaps > 2 hours to break lines
            const TWO_HOURS_MS = 2 * 60 * 60 * 1000;
            const histData = insertGapNulls(historyResult.data || [], 'timestamp', TWO_HOURS_MS);
            const forecastData = forecastResult.data || [];
            const histForecastData = insertGapNulls(histForecastResult.data || [], 'timestamp', TWO_HOURS_MS);

            if (histData.length === 0 && forecastData.length === 0) {
                chartDiv.innerHTML = '<p class="muted">No weather data available.</p>';
                breakdownDiv.innerHTML = '';
                return;
            }

            // Historical data timestamps
            const histTimestamps = histData.map(d => d.timestamp_display || d.timestamp);
            // Forecast data timestamps
            const forecastTimestamps = forecastData.map(d => d.timestamp_display || d.timestamp);
            // Historical forecast timestamps
            const histForecastTimestamps = histForecastData.map(d => d.timestamp_display || d.timestamp);

            // Get current time for "now" line (use last non-null historical point)
            let nowTime = null;
            for (let i = histData.length - 1; i >= 0; i--) {
                if (histData[i].actual_temp != null) {
                    nowTime = histData[i].timestamp_display || histData[i].timestamp;
                    break;
                }
            }

            // Main temperature comparison chart with forecast
            const tempTraces = [
                // Historical actual outdoor
                {
                    x: histTimestamps,
                    y: histData.map(d => d.actual_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Actual Outdoor',
                    line: { color: '#3498db', width: 2 },
                    connectgaps: false,
                    hovertemplate: '%{x}<br>Actual: %{y}¬∞C<extra></extra>'
                },
                // Historical effective temp
                {
                    x: histTimestamps,
                    y: histData.map(d => d.effective_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Effective Temp',
                    line: { color: '#e74c3c', width: 2, dash: 'dot' },
                    connectgaps: false,
                    hovertemplate: '%{x}<br>Effective: %{y}¬∞C<extra></extra>'
                }
            ];

            // Add historical forecast traces if available
            if (histForecastData.length > 0) {
                tempTraces.push({
                    x: histForecastTimestamps,
                    y: histForecastData.map(d => d.forecast_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Forecast Outdoor (hist)',
                    line: { color: '#85c1e9', width: 1.5, dash: 'dash' },
                    connectgaps: false,
                    hovertemplate: '%{x}<br>Fcst Outdoor: %{y}¬∞C<extra></extra>'
                });
                tempTraces.push({
                    x: histForecastTimestamps,
                    y: histForecastData.map(d => d.effective_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Forecast Effective (hist)',
                    line: { color: '#f0b27a', width: 1.5, dash: 'dash' },
                    connectgaps: false,
                    hovertemplate: '%{x}<br>Fcst Effective: %{y}¬∞C<extra></extra>'
                });
            }

            // Add forecast traces if we have forecast data
            if (forecastData.length > 0) {
                // Forecast outdoor temp (dashed)
                tempTraces.push({
                    x: forecastTimestamps,
                    y: forecastData.map(d => d.forecast_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Forecast Outdoor',
                    line: { color: '#3498db', width: 2, dash: 'dash' },
                    connectgaps: false,
                    hovertemplate: '%{x}<br>Forecast: %{y}¬∞C<extra></extra>'
                });
                // Forecast effective temp (dashed + dotted)
                tempTraces.push({
                    x: forecastTimestamps,
                    y: forecastData.map(d => d.effective_temp),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Forecast Effective',
                    line: { color: '#e74c3c', width: 2, dash: 'dashdot' },
                    connectgaps: false,
                    hovertemplate: '%{x}<br>Forecast Eff: %{y}¬∞C<extra></extra>'
                });
            }

            const tempLayout = {
                xaxis: {
                    title: 'Time',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)'
                },
                yaxis: {
                    title: 'Temperature (¬∞C)',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)'
                },
                height: 350,
                margin: { l: 60, r: 30, t: 30, b: 60 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#ffffff',
                font: { family: 'system-ui, -apple-system, sans-serif' },
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: 1.02,
                    xanchor: 'right',
                    x: 1
                },
                dragmode: 'pan',
                hovermode: 'x unified',
                // Add vertical "now" line
                shapes: nowTime ? [{
                    type: 'line',
                    x0: nowTime,
                    x1: nowTime,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: { color: 'rgba(0,0,0,0.3)', width: 2, dash: 'dot' }
                }] : [],
                annotations: nowTime ? [{
                    x: nowTime,
                    y: 1,
                    yref: 'paper',
                    text: 'Now',
                    showarrow: false,
                    font: { size: 10, color: 'rgba(0,0,0,0.5)' },
                    yanchor: 'bottom'
                }] : []
            };

            Plotly.newPlot('effective-temp-chart', tempTraces, tempLayout, chartConfig);

            // Effect breakdown chart (historical + forecast)
            const breakdownTraces = [
                // Historical wind effect
                {
                    x: histTimestamps,
                    y: histData.map(d => d.wind_effect),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Wind Effect',
                    fill: 'tozeroy',
                    line: { color: '#9b59b6', width: 1 },
                    fillcolor: 'rgba(155, 89, 182, 0.3)',
                    connectgaps: false,
                    hovertemplate: '%{x}<br>Wind: %{y}¬∞C<extra></extra>'
                },
                // Historical humidity effect
                {
                    x: histTimestamps,
                    y: histData.map(d => d.humidity_effect),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Humidity Effect',
                    fill: 'tozeroy',
                    line: { color: '#3498db', width: 1 },
                    fillcolor: 'rgba(52, 152, 219, 0.3)',
                    connectgaps: false,
                    hovertemplate: '%{x}<br>Humidity: %{y}¬∞C<extra></extra>'
                },
                // Historical solar effect
                {
                    x: histTimestamps,
                    y: histData.map(d => d.solar_effect),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Solar Effect',
                    fill: 'tozeroy',
                    line: { color: '#f39c12', width: 1 },
                    fillcolor: 'rgba(243, 156, 18, 0.3)',
                    connectgaps: false,
                    hovertemplate: '%{x}<br>Solar: %{y}¬∞C<extra></extra>'
                }
            ];

            // Add forecast effect traces
            if (forecastData.length > 0) {
                breakdownTraces.push(
                    {
                        x: forecastTimestamps,
                        y: forecastData.map(d => d.wind_effect),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Wind (forecast)',
                        line: { color: '#9b59b6', width: 2, dash: 'dash' },
                        connectgaps: false,
                        hovertemplate: '%{x}<br>Wind (fcst): %{y}¬∞C<extra></extra>'
                    },
                    {
                        x: forecastTimestamps,
                        y: forecastData.map(d => d.humidity_effect),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Humidity (forecast)',
                        line: { color: '#3498db', width: 2, dash: 'dash' },
                        connectgaps: false,
                        hovertemplate: '%{x}<br>Humidity (fcst): %{y}¬∞C<extra></extra>'
                    },
                    {
                        x: forecastTimestamps,
                        y: forecastData.map(d => d.solar_effect),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Solar (forecast)',
                        line: { color: '#f39c12', width: 2, dash: 'dash' },
                        connectgaps: false,
                        hovertemplate: '%{x}<br>Solar (fcst): %{y}¬∞C<extra></extra>'
                    }
                );
            }

            const breakdownLayout = {
                xaxis: {
                    title: 'Time',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)'
                },
                yaxis: {
                    title: 'Effect (¬∞C)',
                    showgrid: true,
                    gridcolor: 'rgba(0,0,0,0.1)',
                    zeroline: true,
                    zerolinecolor: 'rgba(0,0,0,0.3)',
                    zerolinewidth: 1
                },
                height: 280,
                margin: { l: 60, r: 30, t: 30, b: 60 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#ffffff',
                font: { family: 'system-ui, -apple-system, sans-serif' },
                legend: {
                    orientation: 'h',
                    yanchor: 'bottom',
                    y: 1.02,
                    xanchor: 'right',
                    x: 1
                },
                dragmode: 'pan',
                hovermode: 'x unified',
                // Add vertical "now" line
                shapes: nowTime ? [{
                    type: 'line',
                    x0: nowTime,
                    x1: nowTime,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: { color: 'rgba(0,0,0,0.3)', width: 2, dash: 'dot' }
                }] : []
            };

            Plotly.newPlot('effect-breakdown-chart', breakdownTraces, breakdownLayout, chartConfig);
        })
        .catch(error => {
            console.error('Failed to load effective temperature data:', error);
            chartDiv.innerHTML = '<p class="muted">Failed to load weather data.</p>';
            breakdownDiv.innerHTML = '';
        });
    }

    // Primary vs Secondary Temperature Chart with dynamic pan loading
    // Track chart state for dynamic loading
    const tempHistoryState = {
        loadedHours: 0,
        isLoading: false,
        data: [],
        minLoadedTime: null,
        maxLoadedTime: null
    };

    function buildTempHistoryTraces(data) {
        const timestamps = data.map(d => d.timestamp_display);
        return [
            // DH Primary Side
            {
                x: timestamps,
                y: data.map(d => d.dh_supply_temp),
                type: 'scatter',
                mode: 'lines',
                name: 'DH Supply',
                line: { color: '#e74c3c', width: 2 },
                hovertemplate: '%{x}<br>DH Supply: %{y}¬∞C<extra></extra>'
            },
            {
                x: timestamps,
                y: data.map(d => d.dh_return_temp),
                type: 'scatter',
                mode: 'lines',
                name: 'DH Return',
                line: { color: '#c0392b', width: 2, dash: 'dot' },
                hovertemplate: '%{x}<br>DH Return: %{y}¬∞C<extra></extra>'
            },
            // House Secondary Side
            {
                x: timestamps,
                y: data.map(d => d.supply_temp),
                type: 'scatter',
                mode: 'lines',
                name: 'House Supply',
                line: { color: '#3498db', width: 2 },
                hovertemplate: '%{x}<br>House Supply: %{y}¬∞C<extra></extra>'
            },
            {
                x: timestamps,
                y: data.map(d => d.return_temp),
                type: 'scatter',
                mode: 'lines',
                name: 'House Return',
                line: { color: '#2980b9', width: 2, dash: 'dot' },
                hovertemplate: '%{x}<br>House Return: %{y}¬∞C<extra></extra>'
            },
            // Outdoor reference
            {
                x: timestamps,
                y: data.map(d => d.outdoor_temperature),
                type: 'scatter',
                mode: 'lines',
                name: 'Outdoor',
                line: { color: '#95a5a6', width: 1, dash: 'dash' },
                hovertemplate: '%{x}<br>Outdoor: %{y}¬∞C<extra></extra>'
            },
            // Predicted supply temp (using effective temperature)
            {
                x: timestamps,
                y: data.map(d => d.supply_temp_heat_curve_ml),
                type: 'scatter',
                mode: 'lines',
                name: 'Predicted Supply',
                line: { color: '#9b59b6', width: 2, dash: 'dashdot' },
                hovertemplate: '%{x}<br>Predicted Supply: %{y}¬∞C<extra></extra>'
            }
        ];
    }

    function updateTemperatureHistoryChart(extendHours = null) {
        const selectEl = document.getElementById('temp-history-days-select');
        const hours = extendHours || parseInt(selectEl.value);
        const chartDiv = document.getElementById('temp-history-chart');

        // If extending, don't show full loading spinner - just indicate loading
        if (!extendHours) {
            chartDiv.innerHTML = '<div class="loading-spinner">Loading temperature data...</div>';
            tempHistoryState.data = [];
        }
        tempHistoryState.isLoading = true;

        fetch(`/api/house/${houseId}/temperature-history?hours=${hours}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                tempHistoryState.isLoading = false;
                const data = result.data || [];

                if (data.length === 0 && !extendHours) {
                    chartDiv.innerHTML = '<div class="no-data-message">No temperature data available. DH variables may not be configured.</div>';
                    return;
                }

                // Update state
                tempHistoryState.loadedHours = hours;
                tempHistoryState.data = data;
                if (data.length > 0) {
                    tempHistoryState.minLoadedTime = new Date(data[0].timestamp);
                    tempHistoryState.maxLoadedTime = new Date(data[data.length - 1].timestamp);
                }

                const traces = buildTempHistoryTraces(data);

                const layout = {
                    xaxis: { title: 'Time', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    yaxis: { title: 'Temperature (¬∞C)', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    height: 400,
                    margin: { l: 60, r: 30, t: 30, b: 60 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: { orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1 },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                if (!extendHours) {
                    chartDiv.innerHTML = '';  // Clear loading message
                }

                // Use react for updates, newPlot for initial
                const plotFn = extendHours ? Plotly.react : Plotly.newPlot;
                plotFn('temp-history-chart', traces, layout, chartConfig)
                    .then(() => {
                        // Add pan handler for dynamic loading (only on initial plot)
                        if (!extendHours) {
                            document.getElementById('temp-history-chart').on('plotly_relayout', (e) => handleChartPan(e, tempHistoryState, 'temp-history-days-select', updateTemperatureHistoryChart));
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        if (!extendHours) {
                            chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                        }
                    });
            })
            .catch(error => {
                tempHistoryState.isLoading = false;
                console.error('Failed to load temperature history:', error);
                if (!extendHours) {
                    chartDiv.innerHTML = '<div class="no-data-message">Failed to load temperature data.</div>';
                }
            });
    }

    // Parse Plotly's display time format "YYYY-MM-DD HH:MM" to Date
    function parseDisplayTime(timeStr) {
        if (!timeStr) return null;
        try {
            // Handle both ISO format and display format
            if (timeStr.includes('T')) {
                return new Date(timeStr);
            }
            // Display format: "2026-01-15 14:30"
            const [datePart, timePart] = timeStr.split(' ');
            if (!datePart) return null;
            const [year, month, day] = datePart.split('-').map(Number);
            const [hour, minute] = (timePart || '00:00').split(':').map(Number);
            return new Date(year, month - 1, day, hour, minute);
        } catch (e) {
            console.warn('Failed to parse time:', timeStr, e);
            return null;
        }
    }

    // Generic pan handler for all charts with hours-based data
    function handleChartPan(eventData, state, selectId, updateFn, maxHours = 720) {
        if (state.isLoading || !eventData['xaxis.range[0]']) return;

        const visibleStart = parseDisplayTime(eventData['xaxis.range[0]']);
        const visibleEnd = parseDisplayTime(eventData['xaxis.range[1]']);

        if (!visibleStart || !visibleEnd || !state.minLoadedTime) return;

        const loadedRange = state.maxLoadedTime - state.minLoadedTime;
        const buffer = loadedRange * 0.1;

        const needsMore = visibleStart < new Date(state.minLoadedTime.getTime() + buffer) ||
                          visibleEnd > new Date(state.maxLoadedTime.getTime() - buffer);

        if (needsMore) {
            const newHours = Math.min(state.loadedHours * 2, maxHours);
            if (newHours > state.loadedHours) {
                console.log(`Extending ${selectId} data from ${state.loadedHours}h to ${newHours}h`);
                updateFn(newHours);

                const selectEl = document.getElementById(selectId);
                if (selectEl) {
                    const options = Array.from(selectEl.options).map(o => parseInt(o.value));
                    const closest = options.reduce((p, c) => Math.abs(c - newHours) < Math.abs(p - newHours) ? c : p);
                    selectEl.value = closest.toString();
                }
            }
        }
    }

    // Generic pan handler for charts with days-based data
    function handleChartPanDays(eventData, state, selectId, updateFn, maxDays = 365) {
        if (state.isLoading || !eventData['xaxis.range[0]']) return;

        const visibleStart = parseDisplayTime(eventData['xaxis.range[0]']);
        const visibleEnd = parseDisplayTime(eventData['xaxis.range[1]']);

        if (!visibleStart || !visibleEnd || !state.minLoadedTime) return;

        const loadedRange = state.maxLoadedTime - state.minLoadedTime;
        const buffer = loadedRange * 0.1;

        const needsMore = visibleStart < new Date(state.minLoadedTime.getTime() + buffer) ||
                          visibleEnd > new Date(state.maxLoadedTime.getTime() - buffer);

        if (needsMore) {
            const newDays = Math.min(state.loadedDays * 2, maxDays);
            if (newDays > state.loadedDays) {
                console.log(`Extending ${selectId} data from ${state.loadedDays}d to ${newDays}d`);
                updateFn(newDays);

                const selectEl = document.getElementById(selectId);
                if (selectEl) {
                    const options = Array.from(selectEl.options).map(o => parseInt(o.value));
                    const closest = options.reduce((p, c) => Math.abs(c - newDays) < Math.abs(p - newDays) ? c : p);
                    selectEl.value = closest.toString();
                }
            }
        }
    }

    // Efficiency Metrics Chart (Delta T) with dynamic pan loading
    const efficiencyState = {
        loadedHours: 0,
        isLoading: false,
        minLoadedTime: null,
        maxLoadedTime: null
    };

    function buildEfficiencyTraces(data) {
        const timestamps = data.map(d => d.timestamp_display);
        return [
            {
                x: timestamps,
                y: data.map(d => d.dh_delta_t),
                type: 'scatter',
                mode: 'lines',
                name: 'DH Delta T',
                fill: 'tozeroy',
                line: { color: '#e74c3c', width: 2 },
                fillcolor: 'rgba(231, 76, 60, 0.2)',
                hovertemplate: '%{x}<br>DH ŒîT: %{y}¬∞C<extra></extra>'
            },
            {
                x: timestamps,
                y: data.map(d => d.house_delta_t),
                type: 'scatter',
                mode: 'lines',
                name: 'House Delta T',
                fill: 'tozeroy',
                line: { color: '#3498db', width: 2 },
                fillcolor: 'rgba(52, 152, 219, 0.2)',
                hovertemplate: '%{x}<br>House ŒîT: %{y}¬∞C<extra></extra>'
            }
        ];
    }

    function updateEfficiencyChart(extendHours = null) {
        const selectEl = document.getElementById('efficiency-days-select');
        const hours = extendHours || parseInt(selectEl.value);
        const chartDiv = document.getElementById('efficiency-chart');
        const summaryDiv = document.getElementById('efficiency-summary');

        if (!extendHours) {
            chartDiv.innerHTML = '<div class="loading-spinner">Loading efficiency data...</div>';
            summaryDiv.innerHTML = '';
        }
        efficiencyState.isLoading = true;

        fetch(`/api/house/${houseId}/efficiency-metrics?hours=${hours}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                efficiencyState.isLoading = false;
                const data = result.data || [];
                const summary = result.summary || {};

                if (data.length === 0 && !extendHours) {
                    chartDiv.innerHTML = '<div class="no-data-message">No efficiency data available.</div>';
                    return;
                }

                // Update state
                efficiencyState.loadedHours = hours;
                if (data.length > 0) {
                    efficiencyState.minLoadedTime = new Date(data[0].timestamp);
                    efficiencyState.maxLoadedTime = new Date(data[data.length - 1].timestamp);
                }

                const traces = buildEfficiencyTraces(data);

                const layout = {
                    xaxis: { title: 'Time', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    yaxis: { title: 'Delta T (¬∞C)', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    height: 350,
                    margin: { l: 60, r: 30, t: 30, b: 60 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: { orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1 },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                if (!extendHours) {
                    chartDiv.innerHTML = '';
                }

                const plotFn = extendHours ? Plotly.react : Plotly.newPlot;
                plotFn('efficiency-chart', traces, layout, chartConfig)
                    .then(() => {
                        if (!extendHours) {
                            document.getElementById('efficiency-chart').on('plotly_relayout', (e) => handleChartPan(e, efficiencyState, 'efficiency-days-select', updateEfficiencyChart));
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        if (!extendHours) chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });

                // Update summary
                if (!extendHours) {
                    summaryDiv.innerHTML = `
                        <div class="metric-item">
                            <div class="metric-value">${summary.avg_dh_delta_t || '-'}¬∞C</div>
                            <div class="metric-label">Avg DH Delta T</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${summary.avg_house_delta_t || '-'}¬∞C</div>
                            <div class="metric-label">Avg House Delta T</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${summary.avg_power || '-'} kW</div>
                            <div class="metric-label">Avg Power</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${summary.max_power || '-'} kW</div>
                            <div class="metric-label">Peak Power</div>
                        </div>
                    `;
                }
            })
            .catch(error => {
                efficiencyState.isLoading = false;
                console.error('Failed to load efficiency data:', error);
                if (!extendHours) chartDiv.innerHTML = '<div class="no-data-message">Failed to load efficiency data.</div>';
            });
    }

    // Real-Time Power & Flow Chart (MBus meter)
    const realtimePowerState = {
        loadedHours: 0,
        isLoading: false,
        data: [],
        minLoadedTime: null,
        maxLoadedTime: null
    };

    function updateRealtimePowerChart(extendHours = null) {
        const selectEl = document.getElementById('realtime-power-days-select');
        if (!selectEl) return;  // Not present on aggregate view

        const hours = extendHours || parseInt(selectEl.value);
        const chartDiv = document.getElementById('realtime-power-chart');
        const cardDiv = document.getElementById('realtime-power-card');

        if (!extendHours) {
            chartDiv.innerHTML = '<div class="loading-spinner">Loading power data...</div>';
            realtimePowerState.data = [];
        }
        realtimePowerState.isLoading = true;

        fetch(`/api/house/${houseId}/realtime-power?hours=${hours}`)
            .then(r => r.ok ? r.json() : { data: [] })
            .then(result => {
                realtimePowerState.isLoading = false;
                const data = result.data || [];

                // Hide card entirely if no MBus power data exists
                if (data.length === 0) {
                    cardDiv.style.display = 'none';
                    return;
                }

                // Show the card
                cardDiv.style.display = '';

                realtimePowerState.loadedHours = hours;
                realtimePowerState.data = data;
                if (data.length > 0) {
                    realtimePowerState.minLoadedTime = new Date(data[0].timestamp);
                    realtimePowerState.maxLoadedTime = new Date(data[data.length - 1].timestamp);
                }

                const timestamps = data.map(d => d.timestamp_display);
                const traces = [
                    {
                        x: timestamps,
                        y: data.map(d => d.dh_power),
                        name: 'Power (kW)',
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: '#e74c3c', width: 1.5 },
                        yaxis: 'y'
                    },
                    {
                        x: timestamps,
                        y: data.map(d => d.dh_flow),
                        name: 'Flow (l/h)',
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: '#3498db', width: 1.5 },
                        yaxis: 'y2'
                    }
                ];

                const layout = {
                    xaxis: { title: 'Time', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    yaxis: { title: 'Power (kW)', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)', side: 'left' },
                    yaxis2: { title: 'Flow (l/h)', overlaying: 'y', side: 'right', showgrid: false },
                    height: 350,
                    margin: { l: 60, r: 60, t: 30, b: 60 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: { orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1 },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                if (!extendHours) {
                    chartDiv.innerHTML = '';
                }

                const plotFn = extendHours ? Plotly.react : Plotly.newPlot;
                plotFn('realtime-power-chart', traces, layout, chartConfig)
                    .then(() => {
                        if (!extendHours) {
                            document.getElementById('realtime-power-chart').on('plotly_relayout', (e) => handleChartPan(e, realtimePowerState, 'realtime-power-days-select', updateRealtimePowerChart));
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        if (!extendHours) chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });
            })
            .catch(error => {
                realtimePowerState.isLoading = false;
                console.error('Failed to load realtime power:', error);
            });
    }

    // Cost Estimate Chart with dynamic pan loading
    const costState = {
        loadedDays: 0,
        isLoading: false,
        minLoadedTime: null,
        maxLoadedTime: null
    };

    function updateCostChart(extendDays = null) {
        const selectEl = document.getElementById('cost-days-select');
        const days = extendDays || parseInt(selectEl.value);
        const price = document.getElementById('price-input').value || 1.20;
        const chartDiv = document.getElementById('cost-chart');
        const summaryDiv = document.getElementById('cost-summary');

        if (!extendDays) {
            chartDiv.innerHTML = '<div class="loading-spinner">Loading cost data...</div>';
            summaryDiv.innerHTML = '';
        }
        costState.isLoading = true;

        fetch(`/api/house/${houseId}/cost-estimate?days=${days}&price=${price}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                costState.isLoading = false;
                const data = result.data || [];
                const summary = result.summary || {};

                // Update data source badge
                if (!extendDays) {
                    updateDataSourceBadge('cost-data-source', result.data_source);
                }

                if (data.length === 0 && !extendDays) {
                    chartDiv.innerHTML = '<div class="no-data-message">No cost data available. Import energy data first.</div>';
                    return;
                }

                // Update state
                costState.loadedDays = days;
                if (data.length > 0) {
                    costState.minLoadedTime = new Date(data[0].timestamp);
                    costState.maxLoadedTime = new Date(data[data.length - 1].timestamp);
                }

                // Group by date for daily costs
                const dailyCosts = {};
                data.forEach(d => {
                    const date = d.timestamp_display.split(' ')[0];
                    if (!dailyCosts[date]) dailyCosts[date] = 0;
                    dailyCosts[date] += d.cost;
                });

                const dates = Object.keys(dailyCosts).sort();
                const costs = dates.map(d => Math.round(dailyCosts[d] * 100) / 100);

                const traces = [{
                    x: dates,
                    y: costs,
                    type: 'bar',
                    name: 'Daily Cost',
                    marker: {
                        color: costs.map(c => c > summary.daily_avg_cost * 1.5 ? '#e74c3c' : '#27ae60')
                    },
                    hovertemplate: '%{x}<br>%{y} SEK<extra></extra>'
                }];

                // Add average line
                if (summary.daily_avg_cost) {
                    traces.push({
                        x: [dates[0], dates[dates.length - 1]],
                        y: [summary.daily_avg_cost, summary.daily_avg_cost],
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Daily Avg',
                        line: { color: '#f39c12', width: 2, dash: 'dash' },
                        hovertemplate: 'Average: %{y} SEK<extra></extra>'
                    });
                }

                const layout = {
                    xaxis: { title: 'Date', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)' },
                    yaxis: { title: 'Cost (SEK)', showgrid: true, gridcolor: 'rgba(0,0,0,0.1)', rangemode: 'tozero' },
                    height: 350,
                    margin: { l: 60, r: 30, t: 30, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: { orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1 },
                    dragmode: 'pan'
                };

                if (!extendDays) {
                    chartDiv.innerHTML = '';
                }

                const plotFn = extendDays ? Plotly.react : Plotly.newPlot;
                plotFn('cost-chart', traces, layout, chartConfig)
                    .then(() => {
                        if (!extendDays) {
                            document.getElementById('cost-chart').on('plotly_relayout', (e) => handleChartPanDays(e, costState, 'cost-days-select', updateCostChart));
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        if (!extendDays) chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });

                // Update summary
                if (!extendDays) {
                    summaryDiv.innerHTML = `
                        <div class="cost-item">
                            <div class="cost-value">${summary.total_kwh || 0} kWh</div>
                            <div class="cost-label">Total Energy</div>
                        </div>
                        <div class="cost-item highlight">
                            <div class="cost-value">${summary.total_cost || 0} SEK</div>
                            <div class="cost-label">Total Cost (${days} days)</div>
                        </div>
                        <div class="cost-item">
                            <div class="cost-value">${summary.daily_avg_kwh || 0} kWh</div>
                            <div class="cost-label">Daily Avg Energy</div>
                        </div>
                        <div class="cost-item">
                            <div class="cost-value">${summary.daily_avg_cost || 0} SEK</div>
                            <div class="cost-label">Daily Avg Cost</div>
                        </div>
                        <div class="cost-item highlight">
                            <div class="cost-value projection">${summary.monthly_projection || 0} SEK</div>
                            <div class="cost-label">Monthly Projection</div>
                        </div>
                    `;
                }
            })
            .catch(error => {
                costState.isLoading = false;
                console.error('Failed to load cost data:', error);
                if (!extendDays) chartDiv.innerHTML = '<div class="no-data-message">Failed to load cost data.</div>';
            });
    }

    // Energy Forecast Chart (24h ahead for demand response)
    function updateEnergyForecastChart() {
        const selectEl = document.getElementById('energy-forecast-hours-select');
        const hours = parseInt(selectEl.value);
        const chartDiv = document.getElementById('energy-forecast-chart');
        const summaryDiv = document.getElementById('energy-forecast-summary');

        chartDiv.innerHTML = '<div class="loading-spinner">Loading energy forecast...</div>';
        summaryDiv.innerHTML = '';

        fetch(`/api/house/${houseId}/energy-forecast?hours=${hours}`)
            .then(r => r.ok ? r.json() : { forecast: [], error: 'Failed to fetch' })
            .then(result => {
                const forecast = result.forecast || [];

                if (forecast.length === 0) {
                    chartDiv.innerHTML = '<div class="no-data-message">No energy forecast available. Forecast is generated every 2 hours when weather data is available.</div>';
                    return;
                }

                // Prepare data for the chart
                const timestamps = forecast.map(d => d.timestamp_display);
                const energyKwh = forecast.map(d => d.heating_energy_kwh);
                const outdoorTemp = forecast.map(d => d.outdoor_temp);
                const solarEffect = forecast.map(d => d.solar_effect);

                // Create hover text with details
                const hoverText = forecast.map(d => {
                    let text = `${d.timestamp_display}<br>` +
                        `Energy: ${d.heating_energy_kwh.toFixed(2)} kWh<br>` +
                        `Power: ${d.heating_power_kw.toFixed(2)} kW<br>` +
                        `Outdoor: ${d.outdoor_temp?.toFixed(1) || '-'}¬∞C`;
                    if (!isAggregate) {
                        text += `<br>Effective: ${d.effective_temp?.toFixed(1) || '-'}¬∞C` +
                            `<br>Solar effect: ${d.solar_effect?.toFixed(2) || '-'}¬∞C` +
                            `<br>Lead time: ${d.lead_time_hours?.toFixed(0) || '-'}h`;
                    }
                    if (isAggregate && d.house_count != null) {
                        text += `<br>(${d.house_count} house${d.house_count !== 1 ? 's' : ''})`;
                    }
                    return text;
                });

                // Energy bar chart
                const energyTrace = {
                    x: timestamps,
                    y: energyKwh,
                    type: 'bar',
                    name: 'Energy (kWh)',
                    marker: {
                        color: energyKwh.map((e, i) => {
                            // Color by solar effect - more green when solar is helping
                            const solar = solarEffect[i] || 0;
                            if (solar > 2) return '#27ae60';  // Strong solar - green
                            if (solar > 1) return '#f39c12';  // Moderate solar - orange
                            return '#FF6B6B';  // Little/no solar - red
                        })
                    },
                    text: hoverText,
                    hoverinfo: 'text'
                };

                // Outdoor temperature line (secondary y-axis)
                const tempTrace = {
                    x: timestamps,
                    y: outdoorTemp,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Outdoor Temp (¬∞C)',
                    yaxis: 'y2',
                    line: { color: '#4ECDC4', width: 2 },
                    marker: { size: 4 }
                };

                const layout = {
                    height: 350,
                    margin: { l: 60, r: 60, t: 30, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    dragmode: 'pan',
                    hovermode: 'x unified',
                    xaxis: {
                        title: 'Hour',
                        tickangle: -45,
                        gridcolor: '#e8e8e8'
                    },
                    yaxis: {
                        title: 'Energy (kWh)',
                        titlefont: { color: '#FF6B6B' },
                        tickfont: { color: '#FF6B6B' },
                        gridcolor: '#e8e8e8',
                        rangemode: 'tozero'
                    },
                    yaxis2: {
                        title: 'Temp (¬∞C)',
                        titlefont: { color: '#4ECDC4' },
                        tickfont: { color: '#4ECDC4' },
                        overlaying: 'y',
                        side: 'right'
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    bargap: 0.1
                };

                chartDiv.innerHTML = '';
                Plotly.newPlot('energy-forecast-chart', [energyTrace, tempTrace], layout, chartConfig)
                    .then(() => {
                        // Update summary
                        const summary = result.summary || {};
                        summaryDiv.innerHTML = `
                            <span class="metric">
                                <span class="value">${summary.total_energy_kwh?.toFixed(1) || '-'}</span>
                                <span class="label">Total kWh (${hours}h)</span>
                            </span>
                            <span class="metric">
                                <span class="value">${summary.avg_power_kw?.toFixed(2) || '-'}</span>
                                <span class="label">Avg Power (kW)</span>
                            </span>
                            <span class="metric">
                                <span class="value">${summary.peak_power_kw?.toFixed(2) || '-'}</span>
                                <span class="label">Peak Power (kW)</span>
                            </span>
                            <span class="metric">
                                <span class="value">${summary.peak_hour || '-'}</span>
                                <span class="label">Peak Hour</span>
                            </span>
                        `;

                        // Add generation time if available
                        if (result.generated_at) {
                            summaryDiv.innerHTML += `
                                <span class="metric" style="opacity: 0.7;">
                                    <span class="value" style="font-size: 0.9em;">${result.generated_at}</span>
                                    <span class="label">Forecast Generated</span>
                                </span>
                            `;
                        }

                        // Show house count for aggregate view
                        if (isAggregate && forecast.length > 0 && forecast[0].house_count != null) {
                            const counts = forecast.map(d => d.house_count);
                            const maxCount = Math.max(...counts);
                            const minCount = Math.min(...counts);
                            const countLabel = minCount === maxCount
                                ? `${maxCount} houses`
                                : `${minCount}-${maxCount} houses`;
                            summaryDiv.innerHTML += `
                                <span class="metric">
                                    <span class="value">${countLabel}</span>
                                    <span class="label">Included</span>
                                </span>
                            `;
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });
            })
            .catch(error => {
                console.error('Failed to load energy forecast:', error);
                chartDiv.innerHTML = '<div class="no-data-message">Failed to load energy forecast.</div>';
            });
    }

    // Flexibility Chart (aggregate only) - shows energy with color based on temp trend
    function updateFlexibilityChart() {
        const selectEl = document.getElementById('flexibility-hours-select');
        if (!selectEl) return;
        const hours = parseInt(selectEl.value);
        const chartDiv = document.getElementById('flexibility-chart');
        const summaryDiv = document.getElementById('flexibility-summary');

        chartDiv.innerHTML = '<div class="loading-spinner">Loading flexibility data...</div>';
        summaryDiv.innerHTML = '';

        fetch(`/api/house/${houseId}/energy-forecast?hours=${hours}`)
            .then(r => r.ok ? r.json() : { forecast: [], error: 'Failed to fetch' })
            .then(result => {
                const forecast = result.forecast || [];

                if (forecast.length === 0) {
                    chartDiv.innerHTML = '<div class="no-data-message">No forecast data available for flexibility analysis.</div>';
                    return;
                }

                // Calculate hourly temperature change rate
                const tempRates = forecast.map((d, i) => {
                    if (i === 0) {
                        // Use forward difference for first point
                        if (forecast.length > 1 && forecast[1].outdoor_temp != null && d.outdoor_temp != null) {
                            return forecast[1].outdoor_temp - d.outdoor_temp;
                        }
                        return 0;
                    }
                    if (d.outdoor_temp != null && forecast[i - 1].outdoor_temp != null) {
                        return d.outdoor_temp - forecast[i - 1].outdoor_temp;
                    }
                    return 0;
                });

                // Color mapping: -2¬∞C/h = red, 0 = yellow, +2¬∞C/h = green
                function rateToColor(rate) {
                    const clamped = Math.max(-2, Math.min(2, rate));
                    const t = (clamped + 2) / 4;  // 0 (red) to 1 (green), 0.5 = yellow

                    let r, g, b;
                    if (t <= 0.5) {
                        // Red to yellow (0 -> 0.5)
                        const s = t / 0.5;
                        r = 231;
                        g = Math.round(76 + (196 - 76) * s);
                        b = Math.round(60 + (15 - 60) * s);
                    } else {
                        // Yellow to green (0.5 -> 1)
                        const s = (t - 0.5) / 0.5;
                        r = Math.round(241 + (39 - 241) * s);
                        g = Math.round(196 + (174 - 196) * s);
                        b = Math.round(15 + (96 - 15) * s);
                    }
                    return `rgb(${r},${g},${b})`;
                }

                const timestamps = forecast.map(d => d.timestamp_display);
                const energyKwh = forecast.map(d => d.heating_energy_kwh);
                const barColors = tempRates.map(r => rateToColor(r));

                // Hover text
                const hoverText = forecast.map((d, i) => {
                    const rate = tempRates[i];
                    const rateStr = rate >= 0 ? `+${rate.toFixed(1)}` : rate.toFixed(1);
                    let flexibility = 'Moderate';
                    if (rate >= 1.5) flexibility = 'High - safe to reduce';
                    else if (rate >= 0.5) flexibility = 'Good';
                    else if (rate <= -1.5) flexibility = 'Low - avoid reducing';
                    else if (rate <= -0.5) flexibility = 'Limited';
                    return `${d.timestamp_display}<br>` +
                        `Energy: ${d.heating_energy_kwh.toFixed(2)} kWh<br>` +
                        `Outdoor: ${d.outdoor_temp?.toFixed(1) || '-'}¬∞C<br>` +
                        `Trend: ${rateStr}¬∞C/h<br>` +
                        `Flexibility: ${flexibility}`;
                });

                const energyTrace = {
                    x: timestamps,
                    y: energyKwh,
                    type: 'bar',
                    name: 'Energy (kWh)',
                    marker: { color: barColors },
                    text: hoverText,
                    hoverinfo: 'text'
                };

                // Temperature change rate line
                const rateTrace = {
                    x: timestamps,
                    y: tempRates,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Temp trend (¬∞C/h)',
                    yaxis: 'y2',
                    line: { color: '#555', width: 2 },
                    marker: { size: 4 },
                    hoverinfo: 'skip'
                };

                // Zero line reference
                const zeroTrace = {
                    x: [timestamps[0], timestamps[timestamps.length - 1]],
                    y: [0, 0],
                    type: 'scatter',
                    mode: 'lines',
                    yaxis: 'y2',
                    line: { color: '#aaa', width: 1, dash: 'dot' },
                    showlegend: false,
                    hoverinfo: 'skip'
                };

                const layout = {
                    height: 350,
                    margin: { l: 60, r: 60, t: 30, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    dragmode: 'pan',
                    hovermode: 'x unified',
                    xaxis: {
                        title: 'Hour',
                        tickangle: -45,
                        gridcolor: '#e8e8e8'
                    },
                    yaxis: {
                        title: 'Energy (kWh)',
                        gridcolor: '#e8e8e8',
                        rangemode: 'tozero'
                    },
                    yaxis2: {
                        title: 'Temp trend (¬∞C/h)',
                        titlefont: { color: '#555' },
                        tickfont: { color: '#555' },
                        overlaying: 'y',
                        side: 'right',
                        zeroline: false
                    },
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    },
                    bargap: 0.1
                };

                chartDiv.innerHTML = '';
                Plotly.newPlot('flexibility-chart', [energyTrace, rateTrace, zeroTrace], layout, chartConfig)
                    .then(() => {
                        // Calculate flexibility summary
                        const greenHours = tempRates.filter(r => r >= 1.0).length;
                        const yellowHours = tempRates.filter(r => r > -0.5 && r < 1.0).length;
                        const redHours = tempRates.filter(r => r <= -0.5).length;
                        const totalSaveable = forecast
                            .filter((d, i) => tempRates[i] >= 0.5)
                            .reduce((sum, d) => sum + d.heating_energy_kwh, 0);

                        summaryDiv.innerHTML = `
                            <span class="metric">
                                <span class="value" style="color:#27ae60">${greenHours}</span>
                                <span class="label">Good hours</span>
                            </span>
                            <span class="metric">
                                <span class="value" style="color:#f1c40f">${yellowHours}</span>
                                <span class="label">Neutral hours</span>
                            </span>
                            <span class="metric">
                                <span class="value" style="color:#e74c3c">${redHours}</span>
                                <span class="label">Avoid cutting</span>
                            </span>
                            <span class="metric">
                                <span class="value">${totalSaveable.toFixed(1)}</span>
                                <span class="label">kWh in green window</span>
                            </span>
                        `;
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });
            })
            .catch(error => {
                console.error('Failed to load flexibility data:', error);
                chartDiv.innerHTML = '<div class="no-data-message">Failed to load flexibility data.</div>';
            });
    }

    // Energy Separation Chart (Heating vs DHW) with dynamic pan loading
    const separationState = {
        loadedDays: 0,
        isLoading: false,
        minLoadedTime: null,
        maxLoadedTime: null
    };

    function updateEnergySeparationChart(extendDays = null) {
        const selectEl = document.getElementById('separation-days-select');
        const days = extendDays || parseInt(selectEl.value);
        const chartDiv = document.getElementById('separation-chart');
        const summaryDiv = document.getElementById('separation-summary');

        if (!extendDays) {
            chartDiv.innerHTML = '<div class="loading-spinner">Loading energy separation data...</div>';
            summaryDiv.innerHTML = '';
        }
        separationState.isLoading = true;

        fetch(`/api/house/${houseId}/energy-separated?days=${days}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                separationState.isLoading = false;
                const data = result.data || [];
                const totals = result.totals || {};
                const kValue = result.k_value;

                if (data.length === 0 && !extendDays) {
                    chartDiv.innerHTML = '<div class="no-data-message">No energy separation data available. Run the calibrator first:<br><code>python heating_energy_calibrator.py --house ' + houseId + ' --write</code></div>';
                    return;
                }

                // Update state
                separationState.loadedDays = days;
                if (data.length > 0) {
                    separationState.minLoadedTime = new Date(data[0].timestamp);
                    separationState.maxLoadedTime = new Date(data[data.length - 1].timestamp);
                }

                const timestamps = data.map(d => d.timestamp_display);
                const hasNoBreakdown = data.some(d => d.no_breakdown);
                const hasHouseCount = isAggregate && data.some(d => d.house_count != null);
                const houseCountSuffix = (d) => hasHouseCount ? `<br>(${d.house_count} house${d.house_count !== 1 ? 's' : ''})` : '';

                // Stacked bar chart: Heating (bottom) + DHW (top)
                // Days without breakdown show 0 for heating/dhw (grey bar handles them)
                const traces = [
                    {
                        x: timestamps,
                        y: data.map(d => d.no_breakdown ? 0 : d.heating_kwh),
                        type: 'bar',
                        name: 'Heating',
                        marker: { color: '#3498db' },
                        text: hasHouseCount ? data.map(d => d.house_count) : null,
                        hovertext: data.map(d => `${d.timestamp_display}<br>Heating: ${d.no_breakdown ? 0 : d.heating_kwh} kWh${houseCountSuffix(d)}`),
                        hoverinfo: 'text'
                    },
                    {
                        x: timestamps,
                        y: data.map(d => d.no_breakdown ? 0 : d.dhw_kwh),
                        type: 'bar',
                        name: 'Hot Water (DHW)',
                        marker: { color: '#e67e22' },
                        hovertext: data.map(d => `${d.timestamp_display}<br>Hot Water: ${d.no_breakdown ? 0 : d.dhw_kwh} kWh${houseCountSuffix(d)}`),
                        hoverinfo: 'text'
                    }
                ];

                // Grey bar for days without enough temperature data for breakdown
                if (hasNoBreakdown) {
                    traces.push({
                        x: timestamps,
                        y: data.map(d => d.no_breakdown ? d.actual_kwh : 0),
                        type: 'bar',
                        name: 'Total (no breakdown)',
                        marker: { color: '#bdc3c7' },
                        hovertext: data.map(d => d.no_breakdown ? `${d.timestamp_display}<br>Total: ${d.actual_kwh} kWh<br>(insufficient temp data)${houseCountSuffix(d)}` : ''),
                        hoverinfo: 'text'
                    });
                }

                // Add markers for actual consumption (no line, just hover info)
                traces.push({
                    x: timestamps,
                    y: data.map(d => d.actual_kwh),
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Actual Total',
                    marker: { color: '#2c3e50', size: 8, symbol: 'diamond' },
                    hovertext: data.map(d => `${d.timestamp_display}<br>Actual: ${d.actual_kwh} kWh${houseCountSuffix(d)}`),
                    hoverinfo: 'text'
                });

                // For aggregate view, add house count as text annotations on bars
                if (hasHouseCount) {
                    const maxCount = Math.max(...data.map(d => d.house_count));
                    const hasVariation = data.some(d => d.house_count !== maxCount);
                    if (hasVariation) {
                        traces.push({
                            x: timestamps,
                            y: data.map(d => d.actual_kwh),
                            type: 'scatter',
                            mode: 'text',
                            name: 'Houses',
                            text: data.map(d => d.house_count < maxCount ? `${d.house_count}/${maxCount}` : ''),
                            textposition: 'top center',
                            textfont: { size: 10, color: '#e74c3c' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        });
                    }
                }

                // Add prediction line (if available)
                const hasPredictions = data.some(d => d.predicted_kwh !== null);
                if (hasPredictions) {
                    traces.push({
                        x: timestamps,
                        y: data.map(d => d.predicted_kwh),
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Predicted Heating',
                        line: { color: '#9b59b6', width: 2, dash: 'dash' },
                        marker: { color: '#9b59b6', size: 6 },
                        hovertemplate: '%{x}<br>Predicted: %{y} kWh<br>Outdoor: %{customdata}¬∞C<extra></extra>',
                        customdata: data.map(d => d.avg_outdoor)
                    });
                }

                const layout = {
                    xaxis: {
                        title: 'Date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        tickangle: -45
                    },
                    yaxis: {
                        title: 'Energy (kWh)',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        rangemode: 'tozero'
                    },
                    barmode: 'stack',
                    height: 400,
                    margin: { l: 60, r: 30, t: 30, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: {
                        orientation: 'h',
                        yanchor: 'bottom',
                        y: 1.02,
                        xanchor: 'right',
                        x: 1
                    },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                if (!extendDays) {
                    chartDiv.innerHTML = '';
                }

                const plotFn = extendDays ? Plotly.react : Plotly.newPlot;
                plotFn('separation-chart', traces, layout, chartConfig)
                    .then(() => {
                        if (!extendDays) {
                            document.getElementById('separation-chart').on('plotly_relayout', (e) => handleChartPanDays(e, separationState, 'separation-days-select', updateEnergySeparationChart));
                        }
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        if (!extendDays) chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });

                // Update summary
                if (!extendDays) {
                    const kDisplay = kValue ? `${(kValue * 1000).toFixed(1)} W/¬∞C` : 'N/A';
                    // Build prediction accuracy display if available
                    let accuracyHtml = '';
                    if (totals.prediction_accuracy && totals.days_with_predictions > 0) {
                        const accColor = totals.prediction_accuracy >= 90 && totals.prediction_accuracy <= 110 ? '#27ae60' : '#e74c3c';
                        accuracyHtml = `
                            <div class="metric-item">
                                <div class="metric-value" style="color: ${accColor}; font-size: 1.2em">${totals.prediction_accuracy}%</div>
                                <div class="metric-label">Prediction Accuracy (${totals.days_with_predictions} days)</div>
                            </div>
                        `;
                    }
                    // For aggregate view, show house count info instead of k-value
                    let houseCountHtml = '';
                    if (isAggregate && data.length > 0 && data[0].house_count != null) {
                        const counts = data.map(d => d.house_count);
                        const maxCount = Math.max(...counts);
                        const minCount = Math.min(...counts);
                        const countLabel = minCount === maxCount
                            ? `${maxCount}`
                            : `${minCount}-${maxCount}`;
                        houseCountHtml = `
                            <div class="metric-item">
                                <div class="metric-value" style="color: #7f8c8d; font-size: 1.2em">${countLabel}</div>
                                <div class="metric-label">Houses Included</div>
                            </div>
                        `;
                    }

                    summaryDiv.innerHTML = `
                        <div class="metric-item">
                            <div class="metric-value">${totals.actual || 0} kWh</div>
                            <div class="metric-label">Total Consumption</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" style="color: #3498db">${totals.heating || 0} kWh</div>
                            <div class="metric-label">Heating (${totals.heating_pct || 0}%)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" style="color: #e67e22">${totals.dhw || 0} kWh</div>
                            <div class="metric-label">Hot Water (${totals.dhw_pct || 0}%)</div>
                        </div>
                        ${isAggregate ? houseCountHtml : `
                        <div class="metric-item">
                            <div class="metric-value" style="color: #7f8c8d; font-size: 1.2em">${kDisplay}</div>
                            <div class="metric-label">Heat Loss Coeff (k)</div>
                        </div>
                        `}
                        ${accuracyHtml}
                    `;
                }
            })
            .catch(error => {
                separationState.isLoading = false;
                console.error('Failed to load energy separation data:', error);
                if (!extendDays) chartDiv.innerHTML = '<div class="no-data-message">Failed to load energy separation data.</div>';
            });
    }

    // Linear regression helper
    function linearRegression(xArr, yArr) {
        const n = xArr.length;
        if (n < 2) return { slope: 0, intercept: 0, r2: 0 };
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
        for (let i = 0; i < n; i++) {
            sumX += xArr[i]; sumY += yArr[i];
            sumXY += xArr[i] * yArr[i];
            sumX2 += xArr[i] * xArr[i];
            sumY2 += yArr[i] * yArr[i];
        }
        const denom = n * sumX2 - sumX * sumX;
        if (denom === 0) return { slope: 0, intercept: sumY / n, r2: 0 };
        const slope = (n * sumXY - sumX * sumY) / denom;
        const intercept = (sumY - slope * sumX) / n;
        const ssRes = yArr.reduce((s, y, i) => s + Math.pow(y - (slope * xArr[i] + intercept), 2), 0);
        const meanY = sumY / n;
        const ssTot = yArr.reduce((s, y) => s + Math.pow(y - meanY, 2), 0);
        const r2 = ssTot === 0 ? 0 : 1 - ssRes / ssTot;
        return { slope, intercept, r2 };
    }

    // Prediction Accuracy Trend Chart
    function updateAccuracyChart() {
        const days = parseInt(document.getElementById('accuracy-days-select').value);
        const chartDiv = document.getElementById('accuracy-chart');
        const summaryDiv = document.getElementById('accuracy-summary');

        chartDiv.innerHTML = '<div class="loading-spinner">Loading prediction accuracy data...</div>';
        summaryDiv.innerHTML = '';

        fetch(`/api/house/${houseId}/energy-separated?days=${days}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                const data = result.data || [];

                // Filter for days with both predicted and actual heating > 0
                const valid = data.filter(d => d.predicted_kwh !== null && d.predicted_kwh > 0 && d.heating_kwh > 0);

                if (valid.length < 2) {
                    chartDiv.innerHTML = '<div class="no-data-message">Not enough prediction data yet. Need at least 2 days with both predicted and actual heating energy.</div>';
                    summaryDiv.innerHTML = '';
                    return;
                }

                const dates = valid.map(d => d.timestamp_display);
                const accuracies = valid.map(d => Math.round(d.predicted_kwh / d.heating_kwh * 1000) / 10);

                // Color-code each marker
                const colors = accuracies.map(a => {
                    if (a >= 90 && a <= 110) return '#27ae60';
                    if (a >= 80 && a <= 120) return '#f39c12';
                    return '#e74c3c';
                });

                const traces = [
                    // Green "good" zone band
                    {
                        x: [dates[0], dates[dates.length - 1]],
                        y: [110, 110],
                        mode: 'lines',
                        line: { color: 'rgba(39,174,96,0)', width: 0 },
                        showlegend: false,
                        hoverinfo: 'skip'
                    },
                    {
                        x: [dates[0], dates[dates.length - 1]],
                        y: [90, 90],
                        mode: 'lines',
                        line: { color: 'rgba(39,174,96,0)', width: 0 },
                        fill: 'tonexty',
                        fillcolor: 'rgba(39,174,96,0.1)',
                        showlegend: false,
                        hoverinfo: 'skip'
                    },
                    // 100% reference line
                    {
                        x: [dates[0], dates[dates.length - 1]],
                        y: [100, 100],
                        mode: 'lines',
                        name: 'Perfect (100%)',
                        line: { color: '#95a5a6', width: 1, dash: 'dash' },
                        hoverinfo: 'skip'
                    },
                    // Accuracy line with colored markers
                    {
                        x: dates,
                        y: accuracies,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Accuracy',
                        line: { color: '#3498db', width: 2 },
                        marker: { color: colors, size: 9, line: { color: '#fff', width: 1 } },
                        hovertemplate: '%{x}<br>Accuracy: %{y}%<extra></extra>'
                    }
                ];

                const layout = {
                    xaxis: {
                        title: 'Date',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        tickangle: -45
                    },
                    yaxis: {
                        title: 'Accuracy (%)',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        zeroline: false
                    },
                    height: 350,
                    margin: { l: 60, r: 30, t: 30, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: {
                        orientation: 'h',
                        yanchor: 'bottom',
                        y: 1.02,
                        xanchor: 'right',
                        x: 1
                    },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                chartDiv.innerHTML = '';
                Plotly.newPlot('accuracy-chart', traces, layout, chartConfig)
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });

                // Summary stats
                const avgAcc = Math.round(accuracies.reduce((s, v) => s + v, 0) / accuracies.length * 10) / 10;
                const bestDay = valid[accuracies.indexOf(accuracies.reduce((best, v) => Math.abs(v - 100) < Math.abs(best - 100) ? v : best))];
                const worstDay = valid[accuracies.indexOf(accuracies.reduce((worst, v) => Math.abs(v - 100) > Math.abs(worst - 100) ? v : worst))];

                // Trend: compare first half average to second half average
                const half = Math.floor(accuracies.length / 2);
                const firstHalf = accuracies.slice(0, half);
                const secondHalf = accuracies.slice(half);
                const firstAvgDev = firstHalf.reduce((s, v) => s + Math.abs(v - 100), 0) / firstHalf.length;
                const secondAvgDev = secondHalf.reduce((s, v) => s + Math.abs(v - 100), 0) / secondHalf.length;
                const trendDiff = firstAvgDev - secondAvgDev;
                let trend, trendColor;
                if (trendDiff > 2) { trend = 'Improving'; trendColor = '#27ae60'; }
                else if (trendDiff < -2) { trend = 'Declining'; trendColor = '#e74c3c'; }
                else { trend = 'Stable'; trendColor = '#7f8c8d'; }

                const avgColor = avgAcc >= 90 && avgAcc <= 110 ? '#27ae60' : (avgAcc >= 80 && avgAcc <= 120 ? '#f39c12' : '#e74c3c');

                summaryDiv.innerHTML = `
                    <div class="metric-item">
                        <div class="metric-value" style="color: ${avgColor}">${avgAcc}%</div>
                        <div class="metric-label">Avg Accuracy (${valid.length} days)</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" style="color: #27ae60">${Math.round(bestDay.predicted_kwh / bestDay.heating_kwh * 1000) / 10}%</div>
                        <div class="metric-label">Best (${bestDay.timestamp_display})</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" style="color: #e74c3c">${Math.round(worstDay.predicted_kwh / worstDay.heating_kwh * 1000) / 10}%</div>
                        <div class="metric-label">Worst (${worstDay.timestamp_display})</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" style="color: ${trendColor}">${trend}</div>
                        <div class="metric-label">Trend</div>
                    </div>
                `;
            })
            .catch(error => {
                console.error('Failed to load accuracy data:', error);
                chartDiv.innerHTML = '<div class="no-data-message">Failed to load prediction accuracy data.</div>';
            });
    }

    // Energy Signature Plot ‚Äî resolution state
    let signatureResolution = 'day';  // 'hour', 'day', 'month'

    function switchSignatureResolution(res) {
        signatureResolution = res;
        // Update button styles
        document.querySelectorAll('.sig-res-btn').forEach(btn => {
            if (btn.dataset.res === res) {
                btn.style.background = '#3498db';
                btn.style.color = '#fff';
                btn.classList.add('active');
            } else {
                btn.style.background = '#fff';
                btn.style.color = '#333';
                btn.classList.remove('active');
            }
        });
        updateSignatureChart();
    }

    function renderSignaturePlot(xVals, yVals, kValue, resolution, chartDiv, summaryDiv) {
        const reg = linearRegression(xVals, yVals);

        // Extend regression line 5¬∞C beyond data range on each side
        const dataXMin = Math.min(...xVals);
        const dataXMax = Math.max(...xVals);
        const xMin = dataXMin - 5;
        const xMax = dataXMax + 5;
        const regLineX = [xMin, xMax];
        const regLineY = regLineX.map(x => Math.max(0, reg.slope * x + reg.intercept));

        // k from regression: slope depends on resolution
        // Day: kWh/day per ¬∞C ‚Üí divide by 24 to get kW/¬∞C ‚Üí √ó1000 for W/¬∞C
        // Hour: kWh/h per ¬∞C ‚Üí already kW/¬∞C ‚Üí √ó1000 for W/¬∞C
        // Month: kWh/month per ¬∞C ‚Üí divide by ~720 to get kW/¬∞C ‚Üí √ó1000 for W/¬∞C
        let kDivisor, yLabel, pointLabel;
        if (resolution === 'hour') {
            kDivisor = 1;
            yLabel = 'Energy (kWh/h)';
            pointLabel = 'Hourly Total';
        } else if (resolution === 'month') {
            kDivisor = 720;
            yLabel = 'Heating Energy (kWh/month)';
            pointLabel = 'Monthly Heating';
        } else {
            kDivisor = 24;
            yLabel = 'Heating Energy (kWh/day)';
            pointLabel = 'Daily Heating';
        }

        const regK = (Math.abs(reg.slope) / kDivisor * 1000).toFixed(1);

        const traces = [
            {
                x: xVals,
                y: yVals,
                mode: 'markers',
                type: 'scatter',
                name: pointLabel,
                marker: {
                    color: '#3498db',
                    size: resolution === 'hour' ? 5 : 10,
                    opacity: resolution === 'hour' ? 0.4 : 0.7,
                    line: { color: '#2980b9', width: resolution === 'hour' ? 0 : 1 }
                },
                hovertemplate: 'Outdoor: %{x}¬∞C<br>Energy: %{y} kWh<extra></extra>'
            },
            {
                x: regLineX,
                y: regLineY,
                mode: 'lines',
                name: `Regression (k\u2248${regK} W/\u00b0C)`,
                line: { color: '#e74c3c', width: 2, dash: 'dash' },
                hoverinfo: 'skip'
            }
        ];

        const layout = {
            xaxis: {
                title: resolution === 'hour' ? 'Outdoor Temperature (\u00b0C)' : 'Effective Outdoor Temperature (\u00b0C)',
                showgrid: true,
                gridcolor: 'rgba(0,0,0,0.1)',
                zeroline: true,
                zerolinecolor: 'rgba(0,0,0,0.2)',
                range: [xMin, xMax]
            },
            yaxis: {
                title: yLabel,
                showgrid: true,
                gridcolor: 'rgba(0,0,0,0.1)',
                rangemode: 'tozero'
            },
            height: 400,
            margin: { l: 60, r: 30, t: 30, b: 60 },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: '#ffffff',
            font: { family: 'system-ui, -apple-system, sans-serif' },
            legend: {
                orientation: 'h',
                yanchor: 'bottom',
                y: 1.02,
                xanchor: 'right',
                x: 1
            },
            dragmode: 'pan',
            hovermode: 'closest'
        };

        chartDiv.innerHTML = '';
        Plotly.newPlot('signature-chart', traces, layout, chartConfig)
            .catch(err => {
                console.error('Plotly render error:', err);
                chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
            });

        // Summary
        const calibratedK = kValue ? `${(kValue * 1000).toFixed(1)} W/\u00b0C` : 'N/A';
        const r2Pct = Math.round(reg.r2 * 100);
        const r2Color = r2Pct >= 80 ? '#27ae60' : (r2Pct >= 60 ? '#f39c12' : '#e74c3c');
        const r2Label = r2Pct >= 80 ? 'Good fit' : (r2Pct >= 60 ? 'Fair fit' : 'Weak fit');

        summaryDiv.innerHTML = `
            <div class="metric-item">
                <div class="metric-value" style="color: #7f8c8d">${calibratedK}</div>
                <div class="metric-label">Calibrated k</div>
            </div>
            <div class="metric-item">
                <div class="metric-value" style="color: #e74c3c">${regK} W/\u00b0C</div>
                <div class="metric-label">Regression k</div>
            </div>
            <div class="metric-item">
                <div class="metric-value" style="color: ${r2Color}">${r2Pct}% (R\u00b2)</div>
                <div class="metric-label">${r2Label}</div>
            </div>
            <div class="metric-item">
                <div class="metric-value">${xVals.length}</div>
                <div class="metric-label">Data Points${resolution === 'hour' ? ' (total energy)' : ''}</div>
            </div>
        `;
    }

    function updateSignatureChart() {
        const days = parseInt(document.getElementById('signature-days-select').value);
        const chartDiv = document.getElementById('signature-chart');
        const summaryDiv = document.getElementById('signature-summary');

        chartDiv.innerHTML = '<div class="loading-spinner">Loading energy signature data...</div>';
        summaryDiv.innerHTML = '';

        if (signatureResolution === 'hour') {
            // Hourly: fetch from dedicated hourly endpoint (total consumption vs outdoor temp)
            fetch(`/api/house/${houseId}/energy-signature-hourly?days=${days}`)
                .then(r => r.ok ? r.json() : { data: [] })
                .then(result => {
                    const data = result.data || [];
                    if (data.length < 5) {
                        chartDiv.innerHTML = '<div class="no-data-message">Not enough hourly data. Need imported energy meter data and outdoor temperature readings.</div>';
                        summaryDiv.innerHTML = '';
                        return;
                    }
                    const xVals = data.map(d => d.outdoor_temp);
                    const yVals = data.map(d => d.consumption_kwh);
                    renderSignaturePlot(xVals, yVals, null, 'hour', chartDiv, summaryDiv);
                })
                .catch(error => {
                    console.error('Failed to load hourly signature:', error);
                    chartDiv.innerHTML = '<div class="no-data-message">Failed to load hourly energy signature data.</div>';
                });

        } else {
            // Day or Month: fetch from energy-separated endpoint
            const fetchDays = signatureResolution === 'month' ? Math.max(days, 90) : days;
            fetch(`/api/house/${houseId}/energy-separated?days=${fetchDays}`)
                .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
                .then(result => {
                    const data = result.data || [];
                    const kValue = result.k_value;

                    if (signatureResolution === 'month') {
                        // Aggregate daily data into monthly buckets
                        const monthly = {};
                        data.forEach(d => {
                            if (d.heating_kwh > 0 && d.avg_effective_outdoor !== null && d.avg_effective_outdoor !== undefined) {
                                const monthKey = d.timestamp_display.substring(0, 7); // YYYY-MM
                                if (!monthly[monthKey]) monthly[monthKey] = { heating: 0, tempSum: 0, count: 0 };
                                monthly[monthKey].heating += d.heating_kwh;
                                monthly[monthKey].tempSum += d.avg_effective_outdoor;
                                monthly[monthKey].count += 1;
                            }
                        });
                        // Only include months with at least 15 days of data
                        const xVals = [], yVals = [];
                        Object.values(monthly).forEach(m => {
                            if (m.count >= 15) {
                                xVals.push(Math.round(m.tempSum / m.count * 10) / 10);
                                yVals.push(Math.round(m.heating * 10) / 10);
                            }
                        });

                        if (xVals.length < 2) {
                            chartDiv.innerHTML = '<div class="no-data-message">Not enough monthly data. Need at least 2 months with 15+ days each. Try extending the period.</div>';
                            summaryDiv.innerHTML = '';
                            return;
                        }
                        renderSignaturePlot(xVals, yVals, kValue, 'month', chartDiv, summaryDiv);

                    } else {
                        // Daily (default)
                        const valid = data.filter(d => d.heating_kwh > 0 && d.avg_effective_outdoor !== null && d.avg_effective_outdoor !== undefined);
                        if (valid.length < 3) {
                            chartDiv.innerHTML = '<div class="no-data-message">Not enough data for energy signature. Need at least 3 days with heating energy and effective outdoor temperature.</div>';
                            summaryDiv.innerHTML = '';
                            return;
                        }
                        const xVals = valid.map(d => d.avg_effective_outdoor);
                        const yVals = valid.map(d => d.heating_kwh);
                        renderSignaturePlot(xVals, yVals, kValue, 'day', chartDiv, summaryDiv);
                    }
                })
                .catch(error => {
                    console.error('Failed to load energy signature data:', error);
                    chartDiv.innerHTML = '<div class="no-data-message">Failed to load energy signature data.</div>';
                });
        }
    }

    // K-Value History Chart
    function updateKValueChart() {
        const selectEl = document.getElementById('k-history-days-select');
        const days = parseInt(selectEl.value);
        const chartDiv = document.getElementById('k-value-chart');
        const summaryDiv = document.getElementById('k-value-summary');

        chartDiv.innerHTML = '<div class="loading-spinner">Loading k-value history...</div>';
        summaryDiv.innerHTML = '';

        fetch(`/api/house/${houseId}/k-value-history?days=${days}`)
            .then(r => r.ok ? r.json() : { data: [], error: 'Failed to fetch' })
            .then(result => {
                const data = result.data || [];
                const currentK = result.current_k;

                if (data.length === 0) {
                    chartDiv.innerHTML = '<div class="no-data-message">No k-value history yet. Recalibration runs every 72 hours.</div>';
                    return;
                }

                const timestamps = data.map(d => d.timestamp_display);
                const kValues = data.map(d => d.k_value * 1000);
                const kMedians = data.map(d => d.k_median * 1000);
                const kStddevUpper = data.map(d => (d.k_median + d.k_stddev) * 1000);
                const kStddevLower = data.map(d => (d.k_median - d.k_stddev) * 1000);

                const traces = [
                    // Stddev band (shaded area)
                    {
                        x: timestamps.concat(timestamps.slice().reverse()),
                        y: kStddevUpper.concat(kStddevLower.slice().reverse()),
                        fill: 'toself',
                        fillcolor: 'rgba(52, 152, 219, 0.15)',
                        line: { color: 'transparent' },
                        name: '¬±1 Std Dev',
                        showlegend: true,
                        hoverinfo: 'skip'
                    },
                    // K-value (15th percentile) - main line
                    {
                        x: timestamps,
                        y: kValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'k (15th pct)',
                        line: { color: '#e74c3c', width: 3 },
                        marker: {
                            size: data.map((_, i) => i === data.length - 1 ? 12 : 6),
                            color: '#e74c3c'
                        },
                        hovertemplate: '%{x}<br>k: %{y:.1f} W/¬∞C<extra></extra>'
                    },
                    // K-median line
                    {
                        x: timestamps,
                        y: kMedians,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'k (median)',
                        line: { color: '#3498db', width: 2, dash: 'dash' },
                        hovertemplate: '%{x}<br>Median: %{y:.1f} W/¬∞C<extra></extra>'
                    }
                ];

                const layout = {
                    xaxis: {
                        title: '',
                        tickangle: -45,
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)'
                    },
                    yaxis: {
                        title: 'k (W/¬∞C)',
                        showgrid: true,
                        gridcolor: 'rgba(0,0,0,0.1)',
                        rangemode: 'tozero'
                    },
                    height: 350,
                    margin: { l: 60, r: 30, t: 30, b: 80 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: '#ffffff',
                    font: { family: 'system-ui, -apple-system, sans-serif' },
                    legend: {
                        orientation: 'h',
                        yanchor: 'bottom',
                        y: 1.02,
                        xanchor: 'right',
                        x: 1
                    },
                    dragmode: 'pan',
                    hovermode: 'x unified'
                };

                // Clear loading spinner before rendering chart
                chartDiv.innerHTML = '';

                Plotly.newPlot('k-value-chart', traces, layout, chartConfig)
                    .then(() => {
                        // Update summary with latest values
                        const latest = data[data.length - 1];
                        const change = data.length > 1 ? (latest.k_value - data[0].k_value) * 1000 : 0;
                        const changeStr = change >= 0 ? `+${change.toFixed(1)}` : `${change.toFixed(1)}`;
                        const changeColor = Math.abs(change) < 5 ? '#27ae60' : '#e67e22';  // Green if stable

                        summaryDiv.innerHTML = `
                            <div class="metric-item">
                                <div class="metric-value" style="color: #e74c3c">${(latest.k_value * 1000).toFixed(1)} W/¬∞C</div>
                                <div class="metric-label">Current k (15th pct)</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" style="color: #3498db">${(latest.k_median * 1000).toFixed(1)} W/¬∞C</div>
                                <div class="metric-label">Median k</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value" style="color: ${changeColor}">${changeStr} W/¬∞C</div>
                                <div class="metric-label">Change</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value">${(latest.confidence * 100).toFixed(0)}%</div>
                                <div class="metric-label">Confidence</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-value">${latest.days_used} days</div>
                                <div class="metric-label">Data Points</div>
                            </div>
                        `;
                    })
                    .catch(err => {
                        console.error('Plotly render error:', err);
                        chartDiv.innerHTML = '<div class="no-data-message">Failed to render chart.</div>';
                    });
            })
            .catch(error => {
                console.error('Failed to load k-value history:', error);
                chartDiv.innerHTML = '<div class="no-data-message">Failed to load k-value history.</div>';
            });
    }

    // Initialize all charts on page load
    document.addEventListener('DOMContentLoaded', function() {
        if (isAggregate) {
            // Aggregate view: energy forecast, flexibility, and energy breakdown
            updateEnergyForecastChart();
            setTimeout(() => updateFlexibilityChart(), 100);
            setTimeout(() => updateEnergySeparationChart(), 200);
            return;
        }

        // Supply & Return chart (top priority - shown first)
        updateSupplyReturnChart();

        // Existing charts
        if (document.getElementById('availability-chart')) {
            renderChart(initialData);
        }
        updateEffectiveTempChart();

        // Other charts - load with slight delay to not overload
        setTimeout(() => updateTemperatureHistoryChart(), 100);
        setTimeout(() => updateEfficiencyChart(), 200);
        setTimeout(() => updateRealtimePowerChart(), 250);
        setTimeout(() => updateEnergyForecastChart(), 300);  // Energy forecast (24h ahead)
        setTimeout(() => updateEnergySeparationChart(), 350);
        setTimeout(() => updateAccuracyChart(), 400);
        setTimeout(() => updateSignatureChart(), 450);
        setTimeout(() => updateKValueChart(), 500);
        setTimeout(() => updateCostChart(), 600);
    });
</script>
{% endblock %}
