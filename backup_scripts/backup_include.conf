#!/bin/bash
###############################################################################
# Shared Backup Configuration
# This file defines what to include in backups - used by both:
#   - backup_to_nas_host.sh
#   - backup_docker_system.sh
#
# SINGLE SOURCE OF TRUTH: Update this file to change what gets backed up
###############################################################################

# Root-level file patterns to backup
ROOT_FILE_PATTERNS=(
    "*.py"
    "*.sh"
    "*.json"
    "*.txt"
    "*.md"
    "*.yml"
    "*.yaml"
    "Dockerfile"
    ".env"
    ".env.example"
)

# Directories to backup (relative to PROJECT_DIR)
# These are copied recursively, excluding common junk
BACKUP_DIRS=(
    "energy_models"
    "webgui"
    "profiles"
    "buildings"
    "nginx"
    "docs"
    "backup_scripts"
    "envs"
)

# Directories/patterns to EXCLUDE from webgui (and other dirs)
EXCLUDE_PATTERNS=(
    "venv"
    "__pycache__"
    "*.pyc"
    ".git"
    "node_modules"
    "*.egg-info"
)

###############################################################################
# Seq logging
###############################################################################

# Source secrets from .env (SEQ_API_KEY, INFLUXDB_TOKEN, etc.)
_ENV_FILE="${SCRIPT_DIR}/../.env"
if [ -f "$_ENV_FILE" ]; then
    # Only import the keys we need, don't pollute the environment
    SEQ_URL=$(grep -m1 '^SEQ_URL=' "$_ENV_FILE" | cut -d= -f2-)
    SEQ_API_KEY=$(grep -m1 '^SEQ_API_KEY=' "$_ENV_FILE" | cut -d= -f2-)
fi
# Fallback for host-side Seq access (container uses seq:5341, host uses localhost:5341)
SEQ_URL="${SEQ_URL/seq:5341/localhost:5341}"
SEQ_URL="${SEQ_URL:-http://localhost:5341}"

# Log a structured event to Seq
# Usage: seq_log "Information" "Backup completed" '{"Size": "42 MB", "Duration": "12s"}'
seq_log() {
    local level="${1:-Information}"
    local message="$2"
    local extra_props="${3:-{\}}"

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")

    local hostname
    hostname=$(hostname)

    # Build JSON payload with jq if available, otherwise manual
    local payload
    if command -v jq &>/dev/null; then
        payload=$(jq -n \
            --arg ts "$timestamp" \
            --arg lvl "$level" \
            --arg msg "$message" \
            --arg host "$hostname" \
            --argjson extra "$extra_props" \
            '{
                Events: [{
                    Timestamp: $ts,
                    Level: $lvl,
                    MessageTemplate: $msg,
                    Properties: ({Source: "backup_script", Hostname: $host} + $extra)
                }]
            }')
    else
        payload="{\"Events\":[{\"Timestamp\":\"${timestamp}\",\"Level\":\"${level}\",\"MessageTemplate\":\"${message}\",\"Properties\":{\"Source\":\"backup_script\",\"Hostname\":\"${hostname}\"}}]}"
    fi

    # Fire and forget â€” never fail the backup because of logging
    curl -s -o /dev/null -X POST \
        "${SEQ_URL}/api/events/raw" \
        -H "Content-Type: application/json" \
        -H "X-Seq-ApiKey: ${SEQ_API_KEY}" \
        -d "$payload" 2>/dev/null || true
}

###############################################################################
# Shared backup function - call this from backup scripts
###############################################################################

backup_codebase_shared() {
    local backup_dir="$1"
    local project_dir="${2:-$PROJECT_DIR}"

    echo -e "${GREEN:-}ðŸ“¦ Backing up codebase...${NC:-}"

    local code_dir="${backup_dir}/codebase"
    mkdir -p "$code_dir"

    local files_backed_up=0

    # Backup root-level files matching patterns
    for pattern in "${ROOT_FILE_PATTERNS[@]}"; do
        for file in "${project_dir}"/${pattern}; do
            if [ -f "$file" ]; then
                cp "$file" "$code_dir/" 2>/dev/null || true
                files_backed_up=$((files_backed_up + 1))
            fi
        done
    done
    echo -e "   ${GREEN:-}âœ… Root files: ${files_backed_up} files${NC:-}"

    # Backup directories
    for dir in "${BACKUP_DIRS[@]}"; do
        if [ -d "${project_dir}/${dir}" ]; then
            mkdir -p "$code_dir/$dir"

            # Copy directory contents, excluding unwanted patterns
            rsync -a --quiet \
                --exclude='venv' \
                --exclude='__pycache__' \
                --exclude='*.pyc' \
                --exclude='.git' \
                --exclude='node_modules' \
                --exclude='*.egg-info' \
                "${project_dir}/${dir}/" "$code_dir/$dir/" 2>/dev/null || \
            cp -r "${project_dir}/${dir}" "$code_dir/" 2>/dev/null || true

            echo -e "   ${GREEN:-}âœ… ${dir}/${NC:-}"
        fi
    done

    # Final cleanup of any __pycache__ that slipped through
    find "$code_dir" -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
    find "$code_dir" -type f -name "*.pyc" -delete 2>/dev/null || true

    # Calculate total size
    local size_bytes=$(du -sb "$code_dir" 2>/dev/null | cut -f1)
    local total_size_mb=$(echo "scale=2; $size_bytes / 1024 / 1024" | bc)

    echo -e "   ${GREEN:-}âœ… Total codebase: ${total_size_mb} MB${NC:-}"
    return 0
}

backup_config_shared() {
    local backup_dir="$1"
    local project_dir="${2:-$PROJECT_DIR}"

    echo -e "${GREEN:-}ðŸ“‹ Backing up configuration files...${NC:-}"

    local config_dir="${backup_dir}/config"
    mkdir -p "$config_dir"

    local files_backed_up=0

    # Essential config files
    local config_files=(
        "docker-compose.yml"
        ".env"
        ".env.example"
        "Dockerfile"
        "requirements.txt"
        "variables_config.json"
        "settings.json"
        "CLAUDE.md"
        "README.md"
    )

    for file in "${config_files[@]}"; do
        if [ -f "${project_dir}/${file}" ]; then
            cp "${project_dir}/${file}" "$config_dir/"
            echo -e "   ${GREEN:-}âœ… ${file}${NC:-}"
            files_backed_up=$((files_backed_up + 1))
        fi
    done

    # Backup scripts directory
    if [ -d "${project_dir}/backup_scripts" ]; then
        mkdir -p "$config_dir/backup_scripts"
        cp -r "${project_dir}/backup_scripts/"* "$config_dir/backup_scripts/" 2>/dev/null || true
        echo -e "   ${GREEN:-}âœ… backup_scripts/${NC:-}"
        files_backed_up=$((files_backed_up + 1))
    fi

    echo -e "   ${GREEN:-}âœ… Backed up ${files_backed_up} config items${NC:-}"
    return 0
}
